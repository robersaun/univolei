***************************************
v2 -> com camera e movimento?
***************************************


streamlit run index.py


def resolve_our_roster_numbers(frames: dict) -> list[int]:
    jg = frames.get("jogadoras", pd.DataFrame()).copy()
    if jg.empty:
        return []
    for col in ["team_id", "player_number"]:
        if col in jg.columns:
            jg[col] = pd.to_numeric(jg[col], errors="coerce")
    ours = jg[jg["team_id"] == OUR_TEAM_ID].dropna(subset=["player_number"]).sort_values("player_number")
    return ours["player_number"].astype(int).unique().tolist()


# Tutorial modal
if st.session_state.get("show_tutorial", False):
    try:
        html_path = BASE_DIR / "tutorial_scout.html"
        if html_path.exists():
            html_content = html_path.read_text(encoding="utf-8")
            components.html(
                f"""
                <div id='uv-modal' style='position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                 width: 90vw; height: 85vh; background-color: white; z-index: 1000;
                 border: 2px solid #ccc; border-radius: 10px; overflow: hidden;'>
                    <button id='uv-close'
                         style='position:absolute; top:10px; right:10px; z-index:1001; background:#ff4b4b; color:white;
                                border:none; border-radius:50%; width:30px; height:30px; cursor:pointer; font-weight:bold;'>X</button>
                    <iframe srcdoc='{html.escape(html_content)}'
                             style='width:100%; height:100%; border:none; margin-top:40px;'></iframe>
                </div>
                <script>
                  (function(){{
                    const btn = document.getElementById('uv-close');
                    btn.addEventListener('click', function(){{
                      try {{
                        const params = new URLSearchParams(window.parent.location.search || "");
                        params.set('uv_tut','off');
                        const newUrl = window.parent.location.pathname + '?' + params.toString() + window.parent.location.hash;
                        window.parent.history.replaceState({{}}, '', newUrl);
                        window.parent.location.reload();
                      }} catch (e) {{
                        const params = new URLSearchParams(window.location.search || "");
                        params.set('uv_tut','off');
                        const newUrl = window.location.pathname + '?' + params.toString() + window.location.hash;
                        window.history.replaceState({{}}, '', newUrl);
                        window.location.reload();
                      }}
                    }});
                  }})();
                </script>
                """,
                height=900, scrolling=True
            )
        else:
            st.error("Arquivo de tutorial não encontrado.")
    except Exception as e:
        st.error(f"Não consegui abrir o tutorial: {e}")
    st.button("❌ Fechar Tutorial", key="close_tutorial_btn",
              on_click=lambda: st.session_state.__setitem__("show_tutorial", False))





Nossos acertos", value=True, key="gm_show_succ")
        with f2: show_errors_gm    = st.checkbox("Nossos erros",   value=True, key="gm_show_err")
        with f3: show_adv_pts_gm   = st.checkbox("ADV acertos",    value=True, key="gm_show_adv_ok")
        with f4: show_adv_errs_gm  = st.checkbox("ADV erros",      value=True, key="gm_show_adv_err")
        with f5:
            nums_all = resolve_our_roster_numbers(st.session_state.frames)
            player_opts = ["Todas"] + nums_all
            _picked = st.selectbox("Jogadora", options=player_opts, index=0, key="gm_players_filter")
            _sel_players_gm = None if _picked == "Todas" else [_picked]

        st.session_state.show_heat_numbers = st.checkbox(
            "Mostrar número/ADV nas bolinhas",
            value

-----------------------------

melhore visivivelmente essa pagina de historico em anexo com algumas coires e melhor layoyt
na tabela de jogos, faça ela ficar bem mais alta, trazendo muitos mais registros. cada jogo precisa ser clicavel, que ao clicar vai abrir as informacoes especificas dele. pode criar um botao fechar lista de jogos que diminui essa tabela de todos eles, mostrando apenas alguns 5 ou 10 registros se fechada e todos eles ou uma lista com paginacao ao ficar aberta.


-----------------------------

tudo certo!!! considere essa minha primeira versao estável. a partir de agora nao mexa em nenhuma funcionalidade ou altere ou erre em mais nada. Só iremos mexer na distancia entre a altura e espaço de uma linha de componente e outra, por isso te pedi as separacoes indicadas no codigo.
vou te enviar meu codigo atual e uma print, indicando os espacos principais que quero que vc diminuia, mas vc pode fazer isso em todos, seja nos dois modos (normal e jogo) e na versao desktop e mobile. vou te enviar o css atual tb

-----------------------------

perfeito por enqanto, siga assim! vou enviar mais alguns poucos ajustes:
1. adicione o botao refazer rally, pode ser depois do botao "Rede" e com um vermelho um pouco mais escuro, pode dar um espaco depois do botao rede a mais
2. adicione comentarios ou linhas "*******" que indica o inicio e fim das linhas ou blocos de componentes, pois para a versao 2 do meu codigo irei iniciar um trabalho de diminuicao de espaços em branco. COm esses comentarios iniciais poderei reposicionar melhor os codigos.

Apenas isso sem erros e sem retirar ou errar em nada, consegue?
me envie essa nova versao para downoad completo

-----------------------------
nesse meu codigo atual corrigido que vou reenviar aqui, quero apenas que vc mude a posicao visual (a ordem) de alguns componentes:
1. a linha do placar e seus numeros e informacao de set a atual devem ser as primeiras informacoes antes da quadra
2.  os filtros nossos acertos, nossos erros, adv acertos e erros, e jogadoras, alem do "mostrar numero adv nas bolinhas" devem ficar abaixo da quadra

é apenas esse reposicionamento que preciso, sem retirar ou estragar nada, consegue fazer apenas isso e me enviar o codigo completinho em 3 partes? pode ser pra copiar ou para fazer download

--------------------------

1. os numeros dos pontos do placar diminuiram, quero eles maior do que eram e mais afastado do Sets: 0 × 0  |  Set: 1 que parmanece no canto onde está
2.  os filtros nossos acertos, nossos erros, adv acertos e erros, e jogadoras, alem do mostrar numero adv nas bolinhas deve ficar depois da quadra, entao a quadra ficará logo abaixo do placar, entendeu? hj eles estao acima da quadra
3. habilite novamente o botao desfazer rally na mesma linha que o botao rede e o coloque do lado dele, pode ser na mesma cor do botao rede
altere apenas isso sem erros e  me envie o codigo novamente 100% completo, sem cortes e sem erros, ok? em 3 partes
Essas alteracoes ficarao boas no modo jogo, mas tome muito cuidado, sao pouquissimas alteracoes. nao retire ou erre em nada, nao mude nada de posicao esquerda e direita, apenas essas que pedi mesmo. consegue fazer isso minimamente sem impactar ou alterar mais nada?

me reenvie o cdogigo 100% completo e corrigido! foi isso que pedi, sem codigos parciais ou faltando (ex: ou cole os blocos de modais completos aqui, iguais aos anteriores >>> ou (conteúdo idêntico ao que você já tinha na versão anterior e outros).. quero todas as funcoes e todas funcionalidades e todo o codigo, sempre!! exceto quando eu te pedir algo fora isso sempre siga esta regra! 

MEU INDEX QUE ESTOU TE ENVIANDO TEM MAIS DE 1600 LINHAS, OU SEJA, ELE DEVE TER PRATICAMENTE O MESMO NUMERO QUANDO VC ME ENVIAR, ENTENDEU? NAO É PRA RETIRAR NADA, APENAS ALTERAR A ORDEM DOS COMPONENTES QUE PEDI E AUMENTAR A FONTE, SEM RETIRA NADA, SEM ME ENVIAR CODIGOS CORTADOS, APENAS FAÇA O QUE PEDI ME ENVIANDO MEU ARQUIVO COMPLETO COM AS CORREÇÕES.
ENVIE ELE EM 3 PARTES PARCIAIS, MAS A SOMA FINAL DE LINHAS TEM QUE SER O CODIGO COMPLETO

--------------------------
os novos botoes de testes ficaram na posicao que gostaria, mas eles apareceram na versao desktop e na mobile, era pra isso acontecer? pode seguir essa forma e faça isso nos botoes jogadoras e atalhos (lembre que jogadoras pode mostrar numeracao ou nome, dependendo da selecao do filtro).
os botoes de testes apareceram na versao desktop e mobile, lembre que deve ficar assim apenas no mobile.. no desktop podem permanecer como esá os atuais de numeracao e  atalho. se fizer tudo certo pode retirar os testes, mas tome muito cuidado na edicao do codigo para nao retirar nenhuma funcionalidade, apenas impelementar essa nova visualizacao de botoes no modo mobile (mais otimizada, pequena e com botoes lado a lado para registro rapido em uma tela só no modo jogo na versao mobile).
me envie os codigos finais do index em 3 partes e do css depois.
----------------------
MEU DEUS, JÁ ESTOU QUASE DESISTINDO... vou ter que te enviar 2 arquivos.. 

Index.py
1. está ok botao historico abre o historico corretamente (só falta corigir o layout de contorno igual aos demais do lado dele)
2. estao ok graficos e Tabelas rápidas do Set — Pontos (Nossos), Erros (Nossos) e Histórico (sequência de rallies)
3. label de atalhos estão crretos

idex_atual.py
do index atual, ESTÃO OK: debug tirando td da tela, filtro de jogadoras por numeracao,  tabela Últimos rallies (set atual) e poucos ultimos ajustes que eu havia pedido, mas SEM RETIRAR NADA FILHO DA PUTA!!!


CONSEGUE GERAR UMA NOVA VERSAO COM TUDO ISSO OK E SEM ESTRAGAR MAIS NADA??????? POR FAVOR!!!

----------------------
APENAS CORRIJA ISSO QUE APARECEU AO CARREGAR O CODIGO E ME CONFIRME: O BOTAO LOB EXISTIA? SÓ ME CONFIRME ISSO MAS ACHO QUE PODE MANTER.. TB REVISE OS LABELS DOS BOTOES DE ATALHOS, POIS O DE BLOQUEIO NAO ERA APENAS "B" PELO QUE LEMBRO
Please replace st.experimental_get_query_params with st.query_params.

st.experimental_get_query_params will be removed after 2024-04-11.

Refer to our docs page for more information.

E O BOTAO HISTÓRICO SÓ PRECISA SER IGUAL O LAYOUT DOS OUTROS BOTOES AO LADO (CONTORNO DELE), A AÇÃO FOI CORRIGIDA

ah.. consegue fazer com a que a var DEBUG_PRINTS tb retire da tela os debugs? acho que assim fica melhor pq posso desabilitar todos os debugs, se eu quiser

É APENAS ISSO PFV!!! SEJA EXTERMAMENTE CUIDADOSO POIS FALTA EXTREMAMENTE POUCO, PFV NAO ERRE MAIS OU NAO ALTERE OU RETIRE MAIS NADA! ME ENVIE O CODIGO FINAL COMPLETO APENAS COM ESSES AJUSTES/OBERVACOES QUE LHE ENVIEI!!!
----------------------

botao historico ainda nao esta funcionando e vc ja tinha corrigido (o historico do menu lateral abaixo do index continua funcionando e vc adicionou outro menu historico na aba lateral nao sei pq, que pode ser retirado)
botao fechar set continua nao funcionando
e parece brincadeira e a pior coisa do universo que vc poderia ter feito... vc retirou todos os botoes de acao que estavam 100% funcionando? só pode ser brincadeira.. veja os ultimos codigos que eles existiam e corrija isso 100% com todas as suas funcionalidades pelo amor de deus, nao retire ou erre em mais nada!!

nessa versao que estou te enviando em anexo, todos os botoes de "atalhos" a que me referi (dia, par e outros) estao todos incluidos e funcionais. aplique todas as suas regras novamente desses botoes, tome muito cuidado com os layouts e tudo mais que está funcionando, nao retire ou errr em mais nada, pfv\!
----------------------

vc ja tinha corrigido o botao historico e agora ele parou novamente, consegue parar de errar?
vi que os botoes fechar set e fechar jogo nao estao funcionando, revise e corrija tb de forma definitiva
veja tb a pontuacao, nao sei se peguei um bug, mas vi um set com 26x1, sendo que os sets so devem ir a 25 pontos, exceto os casos de empate em 24x24 e daí o "vai a 2", que u,a equipe precisa abrir 2 pontos de vantagem para vencer (regras do volei, pesquise)
Consegue fazer apenas isso? estamos quase finalizando e preciso parar de mexer nisso, nao erre ou retire mais nada, pfv. Me envie sempre o codigo completo!
FALTA POUCO!!!
obs: nao revisei as outras funcionalides, mas acredito em vc que nao retirou ou errou em nada. corrija, me envie completo e pode ser em 3 partes para nao ficar travamdo o envio
----------------------

o filtro de jogadoras para as bolinhas daquadra, faca um combo que inicia por "Todas" e depois traz as numeracoes de todas, se selelcionar todas traz todasas bolinhas, se seleciona um numero traz info só daquele numero
label resultado pode trazer os botoes acerto e erro do lado e assim para Mostrar botões por:, Posição:, ação, e Atalhos
ao selecionar o botao jogo, adicione um fechar que se eu nao quiser fazer nada, apenas feche as informacoes
o botao historico funcionou, apenas corrija o layout dele que ficou diferente dos outros botoes (a parte externa do layout do botao)
me explique o sentido dos 2 graficos se o Partida (até agora): Placar por rally nao deveria trazer ex: se nos fizemos o ponto 1 e 3, o ponto 2 foi do adv, o grafico do adv deveria "cortar" a numeraao da partida nesse ponto. se nao for isso entendi errado, se é essa a ideia, corrija
faça iniciar a barra lateral minimizada7
Consegue fazer apenas isso? estamos quase finalizando e preciso parar de mexer nisso, nao erre ou retire mais nada, pfv. Me envie sempre o codigo completo!
FALTA POUCO!!!




----------------------
1. NADA DO BOTAO HISTORICO FUNCIONAR AINDA, O MENU LATERAL FUNCIONA PERFEITO, O DO LADO DO BOTAO TUTORIAL NAO FUNCIONA (PELA DECIMA VEZ STOU TE PEDINDO ISSO)
2. ao selecionar o botao adv, user a cor roxo para erro e uma outra para acerto. Tb respeite as regras de ataque no fundo e frente
3. ao selecionar o botao rede, nao está sendo respeitado a selecao de numero das jogadoras, sempre está registrando como "adv". Respeite as regras das numeracoes e apenas se for adv, registrar adv
4. vi que vc tb retirou o filtro de bolinhas, precisa ter o filtro de erros ou acertos nossos, erros ou acertos do adv e pode inserir um filtro por jogadora (selecionar o numero dela e o filtro trazendo apenas informacoes dela.
5. Ao finalizar o jogo, aparece erro Calling st.rerun() within a callback is a no-op.
Consegue fazer apenas isso? estamos quase finalizando e preciso parar de mexer nisso, nao erre ou retire mais nada, pfv. Me envie sempre o codigo completo!
FALTA POUCO!!!
----------------------


MANTENHA TUDO FUNCIONANDO E FAÇA COM ATENCAO APENAS AS CORRECOES QUE VOU PEDIR (ALGUMAS QUE JÁ ENVIEI MAIS DE UMA VEZ), TOME MTO CUIDADO PARA NAO ERRAR COISAS QUE JA PEDI PARA NAO FAZER
Botao historico do lado de tutorial tem que ser a mesma chamada do botao historico da aba lateral, que funciona
botao tutorial fechar e voltar ao index voltaram a dar erro e nao estao apenas fechando as informacoes
como citei, mantenha tudo que esta funcionando e adicione novamente as tabelas abaixo que retirou nao sei pq (antes de historico de sets)
Partida (até agora)
Sem dados na partida.

📌 KPI por Jogadora (Set atual)
🧾 Tabelas rápidas do Set

CONSEGUE FAZER APENAS ISSO SEM ERROS E SEM RETIRAR OU ERRAR EM NADA? TOME EXTREMO CUIDADO POIS JÁ PEDI DIVERSAS VEZES E ESTOU MTO CANSADO DE ERROS


----------------------

pela milionesima vez, o botao historico nao está abrindo o historico (igual botao da barra lateral)
esses botoes Resultado: Acerto Erro, Posição: Frente Fundo podem ficar antes "do Mostrar botões por:" (mude apenas a posicao deles no index/layout, mais nada)
MEU DEUS DO CÉU, COMO ESTÁ DIFICIL.. pegue as coisas que já pedi e já falei que estavam boas e mantenha elas!!! nao fique errando e retirando coisas de novo infinitamente!!!
vc tirou de novo todas as tabelas abaixo, na posicao que ja tinha indicado e elogiado, além do carregamento inicial dos jogos em aberto (ESTOU REALMENTE CANSADO DISSO)
KPIs Set atual (Set 1)
Sem dados no set atual.

Partida (até agora)
Sem dados na partida.

📌 KPI por Jogadora (Set atual)
🧾 Tabelas rápidas do Set

TOME MUITO CUIDADO E PEGUE AS SOLICITACOES DE HISTÓRICO QUE JÁ PEDI PARA MANTER E TB NAO ERRE EM MAIS NADA, NAO RETIRE NADA DO QUE NAO PEDI, FICOU CLARO??
----------------------
meu deus, voltamos a erros do passado e nao acredito que tenho que falar tudo pra vc.. vc é mto ruim
carregamento dos jogos em aberto foi retirado (nao pedi isso)
historico nao abre e nao faz nd
tutorial ao fechar fica branca a tela
mapa de calor quadra de volei agora ficou antes dos registros, (que horrivel, como vc é burro), pedi apenas em cima das tabelas que pedi.. como vc nao entendeu issotao simples?
nem conferi as acoes do mapa de calor e registro de pontos, botoes e etc, pelo menos isso e todas as outras funcionalidades espero que vc tenha mantido
botao time ficou ótimo
será que dessa vez vc ocnsegue sem fazer mais M?

----------------------
botao historico foi o unico que nao funcionou (deve abrir o historico igual o botao do menu lateral)
no botao time vc pode inserir um arquivo excel padrao para downliad tb (adicional), se precisar te envio o arquivo que tenho, mas foi vc mesmo que criou
coloque o 🗺️ Mapa de Calor (Quadra) antes das tabelas Pontuadoras, Erros (Nossos) e Histórico e antes das demais tabelas (apenas alterar a ordem das informacoes, trazer a quadra antes dessas que citei, ficou claro?)
📊 Histórico de Sets deve ser a ultima tabela
CONSEGUE ALTERAR APENAS ISSO QUE PEDI, SEM RETIRAR OU ERRAR EM NADA E ME ENVIANDO O CODIGO FINAL E COMPLETO SEM ERROS EM 3 PARTES?

-------------------------------
eu te enviei como anexo anteriormente o codigo que tem tudo isso funcionando e vc nao corrigiu,
"botoes time, jogo, tutorial e historico pararam de funcionar e as tabelas de kpi tb foram retiradas. 
KPIs Set atual (Set 1), Partida (até agora),  📌 KPI por Jogadora (Set atual) e 📊 Histórico de Sets" precisam ser exatamente como o codigo que te enviei
mantenha todo o resto como esta neste codigo atual, nao altere ou retire nada do que nao pedi. graficos, carregamento inicial dos jogos em aberto, marcacao dos pontos da quadra, etc etc. só corrija isso que citei

-------------------------------

1. crie um botao que finalize diretamente o jogo
2. os botoes time, jogo, tutorial e historico pararam de funcionar e as tabelas de kpi tb foram retiradas. 
KPIs Set atual (Set 1), Partida (até agora),  📌 KPI por Jogadora (Set atual) e 📊 Histórico de Sets

essa sua ultima versão está perfeita em todos os outros temas, vou apenas enviar uma versão de index que tinha essas funcionalidades. Reaplique apenas essas correções e as tabelas de kpi abaixo da quadra. Consegue fazer isso sem estragar mais nada? me enviando a versão final e completa sem erros, sem cortes de codigo parciais e coompleta, em 3 partes?


-------------------------------
botao segunda nao esta registrando nunca
botao largada e pipe parece que nao registraram bolinhas toda vez (posso estar errado, mas algumas vezes registrou e outras nao)
vc está verificando para nao sobrepor nenhuma bolinha? estou achando que se foi registrado, alguma pode ter ficado em cima da outra.. sempre garanta que elas nao se sobreponham, pois apesar de próximas, 25 bolinhas em cada set no maximo nao deve ser dificil nao deixar que nenhuma se sobreponha
aumente um pouco cada bolinha, elas estao muito pequenas, com isso vai aumentar a leitura da numeracao 

veja os logs abaixo
🔎 Debug Heatmap (Modo Jogo)

Acertos (azul): 9 | Erros (vermelho): 5 | ADV (laranja): 0 | ADV erros: 0

rally_no	player_number	action_u	res_u	who_u	used_x	used_y	origem	cor
6	5.0	LOB	PONTO	NOS	49.2	43.2	fb=FRENTE half=opp ruleY=44.0	azul
7	6.0	BLOQUEIO	PONTO	NOS	9.2	48.2	fb=FRENTE half=opp ruleY=49.0	azul
8	9.0	SAQUE	PONTO	NOS	49.2	43.2	fb=FRENTE half=opp ruleY=44.0	azul
9	9.0	SAQUE	PONTO	NOS	51.4	43.2	fb=FRENTE half=opp ruleY=44.0	azul
10	8.0	PIPE	PONTO	NOS	49.2	43.2	fb=FRENTE half=opp ruleY=44.0	azul
11	5.0	SEGUNDA	PONTO	NOS	49.2	43.2	fb=FRENTE half=opp ruleY=44.0	azul
12	3.0	LOB	PONTO	NOS	51.4	43.2	fb=FRENTE half=opp ruleY=44.0	azul
13	5.0	SEGUNDA	PONTO	NOS	51.4	7.2	fb=FUNDO half=opp ruleY=8.0	azul
14	6.0	PIPE	PONTO	NOS	51.4	7.2	fb=FUNDO half=opp ruleY=8.0	azul
1	6.0	MEIO	ERRO	ADV	50.8	91.2	fb=FUNDO half=our ruleY=92.0	vermelho
2	3.0	MEIO	ERRO	ADV	53.0	91.2	fb=FUNDO half=our ruleY=92.0	vermelho
3	4.0	MEIO	ERRO	ADV	48.6	55.2	fb=FRENTE half=our ruleY=56.0	vermelho
4	6.0	PIPE	ERRO	ADV	50.8	55.2	fb=FRENTE half=our ruleY=56.0	vermelho
5	5.0	SEGUNDA	ERRO	ADV	50.8	55.2	fb=FRENTE half=our ruleY=56.0	vermelho

E PELA PRIMEIRA VEZ VC ACERTOU A DIRECAO DA FRENTE E FUNDO!!! UHU!!!! QUE MILAGRE!!! MANTENHA ISSO PFV E TUDO MAIS QUE JÁ ESTÁ OK... NAO ERRE MAIS E CORRIJA APENAS O QUE PEDI, DIVIDINDO SEMPRE O CODIGO EM 3 PARTES E ME ENVIANDO ELE COMPLETO, SEM CORTES

---------------------------------------------------
vc retirou o carregamento inicial de jogos na ultima versao ? pq fez isso? preciso lhe enviar o ultimo codigo ou vc tem acesso e consegue desffazer o que fez?
botoes segunda e largada nao ainda funcionam
e o botao fundo tambem nao faz nenhuma diferenca se clicado na posicao das bolinhas.. veja os logs aatuais.. nao achei informacoes nele de frente e fundo, vc criou essa informacao? quer colocar o x e y da informacao para irmos ajustando (x e y da frente e x e y do fundo -> apénas uma sugestão) 

Acertos (azul): 19 | Erros (vermelho): 12 | ADV (laranja): 0 | ADV erros: 2

rally_no	player_number	action_u	res_u	who_u	used_x	used_y	origem	cor
14	8.0	SAQUE	PONTO	NOS	47.000000	43.2	fb=— half=opp	azul
15	7.0	SAQUE	PONTO	NOS	49.200000	45.4	fb=— half=opp	azul
16	11.0	SAQUE	PONTO	NOS	49.200000	41.0	fb=— half=opp	azul
17	7.0	BLOQUEIO	PONTO	NOS	9.200000	48.2	fb=— half=opp	azul
19	7.0	SAQUE	PONTO	NOS	51.400000	45.4	fb=— half=opp	azul
20	4.0	LOB	PONTO	NOS	49.200000	45.4	fb=— half=opp	azul
21	4.0	LOB	ERRO	ADV	50.800000	55.2	fb=— half=our	vermelho
22	5.0	SEGUNDA	ERRO	ADV	50.800000	55.2	fb=— half=our	vermelho
23	6.0	PIPE	ERRO	ADV	50.800000	55.2	fb=— half=our	vermelho
24	7.0	RECEPÇÃO	ERRO	ADV	50.800000	55.2	fb=— half=our	vermelho
25	8.0	RECEPÇÃO	ERRO	ADV	53.000000	55.2	fb=— half=our	vermelho
26	8.0	RECEPÇÃO	ERRO	ADV	48.600000	55.2	fb=— half=our	vermelho
27	9.0	BLOQUEIO	ERRO	ADV	10.800000	50.2	fb=— half=our	vermelho
28	9.0	BLOQUEIO	ERRO	ADV	18.333333	50.2	fb=— half=our	vermelho
29	11.0	SAQUE	ERRO	ADV	50.800000	55.2	fb=— half=our	vermelho
31	4.0	LOB	ERRO	ADV	53.000000	55.2	fb=— half=our	vermelho
32	4.0	MEIO	ERRO	ADV	50.800000	55.2	fb=— half=our	vermelho
33	8.0	BLOQUEIO	ERRO	ADV	19.266667	50.2	fb=— half=our	vermelho
18	9.0	REDE	ERRO	NOS	10.800000	49.8	fb=— half=opp	laranja_escuro
30	14.0	REDE	ERRO	NOS	18.333333	49.8	fb=— half=opp	laranja_escuro




algumas solicitacoes ainda nao estao ok, e resou repetindo muito e muito e muito e vc nao conseguindo... vamos a elas:
botoes:	segunda, pipe, saque nao estao registrando acerto ou erro ainda
a posicao das bolinhas sendo marcadas atualmente estaria ok para se selecionado "frente", mas se seleciondo fundo, elas precisam ir bem mais para tras, longe da rede e próximas a linha do final da quadra. Já pedi isso umas 10 vezes e vc nao ajustou ainda.. corrija definitivamente e mostre no debug essa informacao de frente e fundo para que eu te envie 

o carregamento inicial de jogos está ok, ficou bom.. isso e outros temas que estabilizamos, deixe tudo como está.. nao erre ou retire nada!!! e sempre me envie o codigo completo e atuializado, dividido em 3 partes para caso de  erro eu consiga te enviar a parte anterior e vc seguir dali




-------------------------------
pelo que vi vc nao fez quase nada das minhas necessidades que enviei, vamos tentar novamente:
botao largada, segunda, saque, pipe e recepcao nao estao registrando bolinhas (recepcao registra apenas vermelhas)
e essas e nenhum outro registro de bolinhas está respeitando o botao frente e fundo.. todas estao sendo colocadas após a linha dos 3 metros que citei (como fundo). se selecionado "frente" elas devem ser marcadas próxima a rede (nao tanto quando bloqueio), mas antes das linha branca dos 3 metros. corrija apenas isso e me envie o codigo dessa uncao final e completo

e o botao de atalho de acao de rede precisa ser adicionado!!! ele nao existe em tela!!! e registrar sempre uma bolinha vermelha bem colado a rede, pode ser nela inteira, nao so no meio ou nos cantos, igual ao bloqueio. se a insercao desse botao for em outra funcao ou css me envie apenas o codigo dele e mais ou menos a linha a ser inserido
consegue fazer todas essas coreções e me enviar o codigo index completo 100% sem retirar ou errar em nada e sem codigos parciais?
pode enviar em 3 partes para nao travar o envio


vc me enviou duas partes e parte da terceira, envie apenas a parte 3 completa ou a partir de onde parou

# UniVolei Live Scout (Heatmap, Modo Jogo, debug detalhado e prints reais)
from __future__ import annotations

from pathlib import Path
import re
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
import matplotlib as mpl
import streamlit.components.v1 as components
import html
import numpy as np
import time
from datetime import date
import json
from math import ceil

from db_excel import (
    init_or_load, save_all, add_match, add_set,
    append_rally, last_open_match, finalize_match
)
from parser_free import parse_line

DEBUG_PRINTS = True
def debug_print(*args, **kwargs):
    if DEBUG_PRINTS:
        print("[UV-DEBUG]", *args, **kwargs, flush=True)

# =========================
# Config + Estilos
# =========================
st.set_page_config(page_title="", layout="wide", initial_sidebar_state="collapsed")

# anti-scroll-jump: preserva posição
components.html("""
<script>
const KEY='uv_scroll_y';
window.addEventListener('load', ()=>{const y=sessionStorage.getItem(KEY); if(y!==null){window.scrollTo(0,parseInt(y));}});
window.addEventListener('beforeunload', ()=>{sessionStorage.setItem(KEY, window.scrollY.toString());});
</script>
""", height=0)

# =========================
# CSS externo
# =========================
BASE_DIR = Path(__file__).parent.resolve()
def load_css(filename: str = "univolei.css"):
    css_path = BASE_DIR / filename
    if css_path.exists():
        st.markdown(f"<style>{css_path.read_text(encoding='utf-8')}</style>", unsafe_allow_html=True)
    else:
        st.warning(f"Arquivo CSS não encontrado: {filename}")
load_css("univolei.css")

# Título com SVG
st.markdown(
    '''
    <div class="header-title">
      <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" style="margin-right:6px; vertical-align:-2px; flex:0 0 auto;">
        <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M2 12a10 10 0 0 0 20 0" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M12 2a10 10 0 0 0 0 20" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M4.5 4.5a10 10 0 0 1 0 15" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M19.5 4.5a10 10 0 0 0 0 15" fill="none" stroke="currentColor" stroke-width="2"/>
      </svg>
      <span>Vôlei Scout – UniVolei</span>
    </div>
    ''',
    unsafe_allow_html=True
)

# =========================
# Figuras ultra-compactas
# =========================
SMALL_RC = {
    "figure.dpi": 110,
    "axes.titlesize": 8,
    "axes.labelsize": 7,
    "xtick.labelsize": 7,
    "ytick.labelsize": 7,
    "legend.fontsize": 7,
}
mpl.rcParams.update(SMALL_RC)

def small_fig(w=2.6, h=1.15):
    fig, ax = plt.subplots(figsize=(w, h), dpi=110)
    ax.grid(True, alpha=0.15)
    for side in ("top", "right"): ax.spines[side].set_visible(False)
    ax.margins(x=0.02)
    ax.tick_params(length=2.5, width=0.6, pad=1.5)
    return fig, ax

def trim_ax(ax, xlabel="", ylabel="", legend=False, max_xticks=6, max_yticks=5):
    from matplotlib.ticker import MaxNLocator
    if xlabel: ax.set_xlabel(xlabel, fontsize=7, labelpad=1.5)
    if ylabel: ax.set_ylabel(ylabel, fontsize=7, labelpad=1.5)
    ax.xaxis.set_major_locator(MaxNLocator(nbins=max_xticks, integer=True))
    ax.yaxis.set_major_locator(MaxNLocator(nbins=max_yticks, integer=True))
    if not legend and ax.get_legend(): ax.get_legend().remove()
    ax.get_figure().tight_layout(pad=0.15)
    return ax.get_figure()

# =========================
# DataFrame HTML
# =========================
def display_dataframe(df, height=None, use_container_width=False, extra_class: str = ""):
    if df is None or len(df) == 0:
        st.write("_Sem dados._"); return
    classes = ('custom-table ' + extra_class).strip()
    html_table = df.to_html(classes=classes, index=False, escape=False)
    styled_html = f"""
    <div style='overflow:auto; height:{height if height else "auto"}px; width: {"100%" if use_container_width else "auto"};'>
        {html_table}
    </div>
    """
    st.markdown(styled_html, unsafe_allow_html=True)

# =========================
# Estado/Base
# =========================
DEFAULT_DB = str(BASE_DIR / "volei_base_dados.xlsx")

if "db_path" not in st.session_state: st.session_state.db_path = DEFAULT_DB
if "frames" not in st.session_state: st.session_state.frames = init_or_load(Path(st.session_state.db_path))
if "match_id" not in st.session_state: st.session_state.match_id = None
if "set_number" not in st.session_state: st.session_state.set_number = None
if "auto_close" not in st.session_state: st.session_state.auto_close = True
if "graph_filter" not in st.session_state: st.session_state.graph_filter = "Ambos"
st.session_state.setdefault("data_rev", 0)

# chaves auxiliares
st.session_state.setdefault("q_side", "Nós")
st.session_state.setdefault("q_result", "Acerto")
st.session_state.setdefault("q_action", "d")
st.session_state.setdefault("q_position", "Frente")  # NOVO
st.session_state.setdefault("last_selected_player", None)
st.session_state.setdefault("show_cadastro", False)
st.session_state.setdefault("show_tutorial", False)
st.session_state.setdefault("show_config_team", False)
st.session_state.setdefault("line_input_text", "")
st.session_state.setdefault("perf_logs", [])

# Heatmap / clique
st.session_state.setdefault("last_court_click", None)   # {"x":float,"y":float,"ts":int}
st.session_state.setdefault("heatmap_debug", True)

# Estado do Modo Jogo
st.session_state.setdefault("game_mode", False)

# Rótulo botões (Número | Nome)
st.session_state.setdefault("btn_label_mode", "Número")
st.session_state.setdefault("player_label_mode", "Número")

# Mostrar números nas bolinhas
st.session_state.setdefault("show_heat_numbers", False)

# =========== Debug/prints ===========
st.session_state.setdefault("dbg_prints", [])
def dbg_print(msg: str):
    ts = time.strftime("%H:%M:%S")
    line = f"[{ts}] {msg}"
    st.session_state["dbg_prints"] = (st.session_state["dbg_prints"] + [line])[-200:]
    print(line)

# Captura de clique via query param
def _uv_handle_court_click():
    try:
        payload = st.query_params.get("uv_click", None)
    except Exception:
        payload = None
    if not payload:
        return
    try:
        xs, ys = payload.split(",")[:2]
        x = float(xs); y = float(ys)  # normalizado [0..1]
        st.session_state["last_court_click"] = {"x": x, "y": y, "ts": int(time.time())}
        dbg_print(f"Clique capturado: x={x:.4f}, y={y:.4f} (0..1).")
        try:
            del st.query_params["uv_click"]
        except Exception:
            pass
    except Exception as e:
        dbg_print(f"Falha lendo uv_click: {e}")
        try:
            del st.query_params["uv_click"]
        except Exception:
            pass
_uv_handle_court_click()

# Perf logs
PERF_DEBUG = False
def _add_perf_log(msg: str):
    logs = st.session_state.get("perf_logs", [])
    logs.append(f"{time.strftime('%H:%M:%S')} {msg}")
    st.session_state["perf_logs"] = logs[-30:]

frames = st.session_state.frames

# =========================
# Normalização jogadoras
# =========================
def _normalize_jogadoras_df(df_in: pd.DataFrame) -> pd.DataFrame:
    if df_in is None or df_in.empty:
        return pd.DataFrame(columns=["team_id", "player_number", "player_name", "position"])
    df = df_in.copy(); rename_map = {}
    cols_lower = {c.lower(): c for c in df.columns}
    for cand in ["team_id", "id_time", "time_id", "equipe_id", "id_equipe", "idteam", "time"]:
        if cand in cols_lower: rename_map[cols_lower[cand]] = "team_id"; break
    for cand in ["player_number", "numero", "número", "num", "nro", "jogadora_numero", "dorsal"]:
        if cand in cols_lower: rename_map[cols_lower[cand]] = "player_number"; break
    for cand in ["player_name", "nome", "jogadora", "athlete", "atleta", "name"]:
        if cand in cols_lower: rename_map[cols_lower[cand]] = "player_name"; break
    for cand in ["position", "posicao", "posição", "pos", "role", "função", "funcao"]:
        if cand in cols_lower: rename_map[cols_lower[cand]] = "position"; break
    if rename_map: df = df.rename(columns=rename_map)
    for c in ["team_id","player_number","player_name","position"]:
        if c not in df.columns: df[c] = None
    df["team_id"] = pd.to_numeric(df["team_id"], errors="coerce")
    df["player_number"] = pd.to_numeric(df["player_number"], errors="coerce")
    df["position"] = df["position"].astype(str).str.strip().str.lower()
    df["player_name"] = df["player_name"].astype(str).str.strip()
    return df

if "jogadoras" in frames:
    frames["jogadoras"] = _normalize_jogadoras_df(frames["jogadoras"])
    st.session_state.frames = frames

# =========================
# Helpers DB/lógica
# =========================
OUR_TEAM_ID = 1

# >>> AÇÃO "rede" incluída <<<
ACT_MAP = {
    "d": "Diagonal","l": "Paralela","m": "Meio","lob": "Largada","seg": "Segunda",
    "pi": "Pipe","re": "Recepção","b": "Bloqueio","sa": "Saque","rede": "Rede"
}
REVERSE_ACT_MAP = {v: k for k, v in ACT_MAP.items()}

ACTION_CODE_TO_NAME = {
    "d": "DIAGONAL","l": "LINHA","m": "MEIO","lob": "LOB","seg": "SEGUNDA",
    "pi": "PIPE","re": "RECEPÇÃO","b": "BLOQUEIO","sa": "SAQUE","rede": "REDE"
}
ACTION_SYNONYM_TO_NAME = {
    "diagonal":"DIAGONAL","diag":"DIAGONAL",
    "linha":"LINHA","paralela":"LINHA",
    "meio":"MEIO",
    "largada":"LOB","lob":"LOB",
    "segunda":"SEGUNDA","seg":"SEGUNDA",
    "pipe":"PIPE","pi":"PIPE",
    "recepcao":"RECEPÇÃO","recepção":"RECEPÇÃO","re":"RECEPÇÃO",
    "bloqueio":"BLOQUEIO","bloq":"BLOQUEIO","b":"BLOQUEIO",
    "saque":"SAQUE","sa":"SAQUE",
    "rede":"REDE"
}
ATTACK_ACTIONS = ["DIAGONAL","LINHA","PIPE","SEGUNDA","LOB","MEIO"]

def team_name_by_id(fr: dict, team_id: int | None) -> str:
    eq = fr.get("equipes", pd.DataFrame())
    if eq.empty or team_id is None: return "Equipe"
    eq = eq.copy(); eq["team_id"] = pd.to_numeric(eq["team_id"], errors="coerce")
    row = eq.loc[eq["team_id"] == int(team_id)]
    return str(row.iloc[0]["team_name"]) if not row.empty else f"Equipe {int(team_id)}"

def current_set_df(fr: dict, match_id: int, set_number: int) -> pd.DataFrame:
    rl = fr["rallies"]
    return rl[(rl["match_id"] == match_id) & (rl["set_number"] == set_number)].copy().sort_values("rally_no")

def set_score_from_df(df: pd.DataFrame) -> tuple[int, int]:
    if df.empty: return 0, 0
    last = df.iloc[-1]
    return int(last["score_home"]), int(last["score_away"])

def update_sets_score_and_match(fr: dict, match_id: int) -> tuple[int,int]:
    sets_df = fr["sets"]; mt = fr["amistosos"]
    sets_m = sets_df[sets_df["match_id"] == match_id]
    home_sets = int((sets_m["winner_team_id"] == 1).sum())
    away_sets = int((sets_m["winner_team_id"] == 2).sum())
    mt_mask = (mt["match_id"] == match_id)
    mt.loc[mt_mask, "home_sets"] = home_sets; mt.loc[mt_mask, "away_sets"] = away_sets
    fr["amistosos"] = mt
    return home_sets, away_sets

def _apply_set_winner_and_proceed(home_pts: int, away_pts: int):
    frames = st.session_state.frames
    match_id = st.session_state.match_id
    set_number = st.session_state.set_number
    winner_id = 1 if home_pts > away_pts else 2
    stf = frames["sets"]
    mask = (stf["match_id"] == match_id) & (stf["set_number"] == set_number)
    stf.loc[mask, "winner_team_id"] = winner_id
    frames["sets"] = stf
    home_sets, away_sets = update_sets_score_and_match(frames, match_id)
    save_all(Path(st.session_state.db_path), frames)
    if home_sets >= 3 or away_sets >= 3:
        finalize_match(frames, match_id); save_all(Path(st.session_state.db_path), frames)
        st.success(f"Set {set_number} encerrado ({home_pts} x {away_pts}). Partida finalizada: {home_sets} x {away_sets} em sets.")
        st.session_state.match_id = None; st.session_state.set_number = None
    else:
        st.session_state.set_number = int(set_number) + 1
        add_set(frames, match_id=match_id, set_number=st.session_state.set_number)
        save_all(Path(st.session_state.db_path), frames)
        st.success(f"Set {set_number} encerrado ({home_pts} x {away_pts}). Novo set: {st.session_state.set_number}")

def auto_close_set_if_needed() -> None:
    if not st.session_state.auto_close: return
    frames = st.session_state.frames
    match_id = st.session_state.match_id
    set_number = st.session_state.set_number
    if match_id is None or set_number is None: return
    df_cur = current_set_df(frames, match_id, set_number)
    if df_cur.empty: return
    home_pts, away_pts = set_score_from_df(df_cur)
    target = 15 if int(set_number) == 5 else 25
    diff = abs(home_pts - away_pts)
    if (home_pts >= target or away_pts >= target) and diff >= 2:
        _apply_set_winner_and_proceed(home_pts, away_pts)

def recompute_set_score_fields(fr: dict, match_id: int, set_number: int):
    rl = fr["rallies"]
    sub = rl[(rl["match_id"]==match_id) & (rl["set_number"]==set_number)].copy().sort_values("rally_no")
    home = away = 0; rows = []
    for _, r in sub.iterrows():
        who = r["who_scored"]
        if who == "NOS": home += 1
        elif who == "ADV": away += 1
        r["score_home"] = home; r["score_away"] = away; rows.append(r)
    rl = rl[~((rl["match_id"]==match_id) & (rl["set_number"]==set_number))]
    if rows: rl = pd.concat([rl, pd.DataFrame(rows)], ignore_index=True)
    fr["rallies"] = rl
    stf = fr["sets"]; mask = (stf["match_id"]==match_id) & (stf["set_number"]==set_number)
    stf.loc[mask, "home_points"] = home; stf.loc[mask, "away_points"] = away
    fr["sets"] = stf

def undo_last_rally_current_set():
    """Rápido: remove só o último evento e restaura o placar para o penúltimo."""
    fr = st.session_state.frames
    match_id = st.session_state.match_id
    set_number = st.session_state.set_number
    rl = fr["rallies"]
    sub = rl[(rl["match_id"]==match_id) & (rl["set_number"]==set_number)].copy().sort_values("rally_no")
    if sub.empty:
        st.warning("Não há rallies para desfazer neste set."); return
    last_row = sub.iloc[-1]
    last_rally_id = last_row["rally_id"]
    rl = rl[rl["rally_id"] != last_rally_id]
    fr["rallies"] = rl
    if len(sub) >= 2:
        prev = sub.iloc[-2]
        hp, ap = int(prev["score_home"]), int(prev["score_away"])
    else:
        hp, ap = 0, 0
    stf = fr["sets"]
    mask = (stf["match_id"]==match_id) & (stf["set_number"]==set_number)
    stf.loc[mask, "home_points"] = hp; stf.loc[mask, "away_points"] = ap
    fr["sets"] = stf
    save_all(Path(st.session_state.db_path), fr)
    st.session_state.data_rev += 1
    dbg_print(f"Desfeito rally_id={last_rally_id}. Placar {hp}-{ap} (sem recomputar tudo).")
    st.success("Último rally desfeito.")

# ===== who_scored e ação =====
def _fix_who_scored_from_raw_and_row(raw_line: str, row: dict) -> dict:
    try:
        tokens = raw_line.strip().split()
        if not tokens: return row
        prefix = tokens[0]  # "1" (Nós executa) ou "0" (Adv executa)
        is_error = tokens[-1].lower() == "e"
        if prefix == "1":
            row["who_scored"] = "ADV" if is_error else "NOS"
        elif prefix == "0":
            row["who_scored"] = "NOS" if is_error else "ADV"
        row["result"] = "ERRO" if is_error else "PONTO"
    except Exception:
        pass
    return row

def _normalize_action_in_row(row: dict) -> dict:
    a = str(row.get("action", "") or "").strip().lower()
    if not a:
        raw = str(row.get("raw_text", "")).strip()
        toks = raw.split()
        if toks:
            last = toks[-1].lower()
            if last == "e" and len(toks) >= 2:
                a = toks[-2].lower()
            else:
                a = last
    if a in ACTION_CODE_TO_NAME:
        name = ACTION_CODE_TO_NAME[a]
    elif a in ACTION_SYNONYM_TO_NAME:
        name = ACTION_SYNONYM_TO_NAME[a]
    else:
        name = str(row.get("action", "") or "").strip().upper()
        if name in ("", "NA", "NONE"): name = ""
    row["action"] = name
    return row

def _fast_apply_scores_to_row(row: dict):
    frames_local = st.session_state.frames
    mid, sn = st.session_state.match_id, st.session_state.set_number
    df_cur = current_set_df(frames_local, mid, sn)
    if df_cur.empty:
        home, away = 0, 0
    else:
        last = df_cur.iloc[-1]
        home, away = int(last["score_home"]), int(last["score_away"])
    if row.get("who_scored") == "NOS": home += 1
    elif row.get("who_scored") == "ADV": away += 1
    row["score_home"] = home; row["score_away"] = away
    return row

# ==== CLICK MAPA (compat) ====
def _capture_court_click_from_query():
    try:
        params = dict(st.query_params)
        if "uvx" in params and "uvy" in params:
            x = float(params.get("uvx")); y = float(params.get("uvy"))
            ts = int(params.get("uvt", "0") or 0)
            st.session_state["last_court_click"] = {"x": x, "y": y, "ts": ts}
            dbg_print(f"Clique (uvx/uvy) recebido: x={x:.4f}, y={y:.4f}")
            newp = {k: v for k, v in dict(st.query_params).items() if not k.startswith("uv")}
            st.query_params.from_dict(newp)
    except Exception as e:
        dbg_print(f"Falha ao ler uvx/uvy: {e}")
_capture_court_click_from_query()

def quick_register_line(raw_line: str):
    if not raw_line.strip():
        dbg_print("Linha vazia ignorada."); return
    t0 = time.perf_counter()
    row = parse_line(raw_line)
    row_before = row.copy()
    row = _fix_who_scored_from_raw_and_row(raw_line, row)
    row = _normalize_action_in_row(row)
    # Posição Frente/Fundo
    row["position_zone"] = str(st.session_state.get("q_position","Frente")).strip().upper()
    row = _fast_apply_scores_to_row(row)

    # clique pendente
    last_click = st.session_state.get("last_court_click")
    used_xy = None
    if last_click and isinstance(last_click, dict):
        row["court_x"] = float(last_click.get("x", 0.0))
        row["court_y"] = float(last_click.get("y", 0.0))
        used_xy = ("clique", row["court_x"], row["court_y"])
        st.session_state["last_court_click"] = None

    t1 = time.perf_counter()
    append_rally(st.session_state.frames, match_id=st.session_state.match_id, set_number=st.session_state.set_number, row=row)
    save_all(Path(st.session_state.db_path), st.session_state.frames)
    st.session_state.data_rev += 1
    auto_close_set_if_needed()
    if PERF_DEBUG:
        t2 = time.perf_counter()
        _add_perf_log(f"parse+fix+score: {(t1-t0)*1000:.1f} ms | append+save+auto: {(t2-t1)*1000:.1f} ms")

    dbg_print(
        f"REGISTRO: raw='{raw_line}' -> action='{row.get('action')}', result='{row.get('result')}', "
        f"who_scored='{row.get('who_scored')}', player={row.get('player_number')}, "
        f"pos={row.get('position_zone')}, placar={row.get('score_home')}-{row.get('score_away')}, "
        f"xy={'%s %.3f %.3f' % used_xy if used_xy else '—'} | row_before={row_before}"
    )

def quick_register_click(side: str, number: int | None, action: str, is_error: bool):
    prefix = "1" if side == "NOS" else "0"
    num = f"{number}" if number is not None else ""
    line = f"{prefix} {num} {action}{' e' if is_error else ''}".strip()
    quick_register_line(line)

def resolve_our_roster_numbers(frames: dict) -> list[int]:
    jg = frames.get("jogadoras", pd.DataFrame()).copy()
    if jg.empty: return []
    for col in ["team_id","player_number"]:
        if col in jg.columns: jg[col] = pd.to_numeric(jg[col], errors="coerce")
    ours = jg[jg["team_id"] == OUR_TEAM_ID].dropna(subset=["player_number"]).sort_values("player_number")
    return ours["player_number"].astype(int).unique().tolist()

def roster_for_ui(frames: dict) -> list[dict]:
    jg = frames.get("jogadoras", pd.DataFrame()).copy()
    if jg.empty: return []
    for col in ["team_id","player_number"]:
        if col in jg.columns: jg[col] = pd.to_numeric(jg[col], errors="coerce")
    ours = jg[(jg["team_id"] == OUR_TEAM_ID) & (~jg["player_number"].isna())].copy()
    if ours.empty: return []
    ours["player_number"] = ours["player_number"].astype(int)
    ours["player_name"] = ours["player_name"].astype(str)
    ours = ours.sort_values("player_number")
    return ours[["player_number","player_name"]].rename(
        columns={"player_number":"number","player_name":"name"}
    ).to_dict("records")

def player_name_by_number(frames: dict, number: int | None) -> str:
    if number is None: return ""
    jg = frames.get("jogadoras", pd.DataFrame())
    if jg is None or jg.empty: return ""
    row = jg[(pd.to_numeric(jg["team_id"], errors="coerce")==OUR_TEAM_ID) &
             (pd.to_numeric(jg["player_number"], errors="coerce")==int(number))]
    return (str(row.iloc[0]["player_name"]) if not row.empty else "")

# central de registro
def register_current(number: int | None = None, action: str | None = None):
    side_code = "NOS" if st.session_state.get("q_side", "Nós") == "Nós" else "ADV"
    is_err = (st.session_state.get("q_result", "Acerto") == "Erro")
    act = action if action is not None else st.session_state.get("q_action", "d")
    num_val = number if number is not None else st.session_state.get("last_selected_player", None)
    if num_val is None:
        raw = st.session_state.get("line_input_text", "")
        m = re.findall(r"\b(\d{1,2})\b", raw)
        num_val = int(m[-1]) if m else None

    # ação 'rede' => sempre erro nosso (bolinha vermelha colada à rede)
    if str(act).lower() == "rede":
        side_code = "ADV"
        is_err = True

    dbg_print(f"register_current: side={side_code}, num={num_val}, action={act}, is_err={is_err}, pos={st.session_state.get('q_position')}")
    quick_register_click(side_code, num_val, act, is_err)

# ========= HEATMAP =========
def _y_for_half(half: str, fb: str | None) -> float:
    """
    Metade superior ('opp') ≈ adversário; metade inferior ('our') ≈ nós.
    Frente = antes dos 3m (perto da rede); Fundo = perto da linha de fundo.
    """
    if fb == "FRENTE":
        return 41.0 if half == "opp" else 59.0   # antes dos 3m
    if fb == "FUNDO":
        return 14.0 if half == "opp" else 86.0   # perto da linha de fundo
    return 28.0 if half == "opp" else 72.0       # neutro

def _y_net_touch(half: str) -> float:
    return 49.0 if half == "opp" else 51.0

def _x_for_action(act: str) -> float:
    if act in ("MEIO","PIPE","SEGUNDA","SAQUE","REDE","BLOQUEIO","LOB"):
        return 50.0
    if act == "DIAGONAL": return 28.0
    if act == "LINHA":    return 82.0
    return 50.0

def build_heat_points(df: pd.DataFrame,
                      selected_players: list[int] | None,
                      include_success: bool,
                      include_errors: bool,
                      include_adv_points: bool,
                      include_adv_errors: bool,
                      return_debug: bool = False):
    """
    Correções:
    - “Segunda”, “Pipe” e “Saque” passam a plotar normalmente (acerto/erro).
    - Frente/Fundo aplicado em TODAS as ações (inclusive Diagonal e Paralela).
    - “Rede” e “Bloqueio” colados à rede (espalhando no eixo X).
    """
    if df is None or df.empty:
        empty_dbg = pd.DataFrame(columns=["rally_no","player_number","action_u","res_u","who_u","used_x","used_y","origem","cor"])
        return ([], [], [], [], empty_dbg) if return_debug else ([], [], [], [])

    def _norm_action(a: str) -> str:
        a = (a or "").strip().upper()
        if a in ("M",): return "MEIO"
        if a in ("D",): return "DIAGONAL"
        if a in ("L","PARALELA"): return "LINHA"
        if a in ("LOB","LARGADA"): return "LOB"
        if a in ("PI","PIPE"): return "PIPE"
        if a in ("SEG","SEGUNDA"): return "SEGUNDA"
        if a in ("RE","RECEPCAO","RECEPÇÃO"): return "RECEPÇÃO"
        if a in ("SA","SAQUE"): return "SAQUE"
        if a in ("B","BLOQ","BLOQUEIO"): return "BLOQUEIO"
        if a in ("REDE",): return "REDE"
        return a

    # inclui 'position_zone' e outras colunas como fonte de Frente/Fundo
    FB_COLS = ["position_zone","pos_fb","posicao_fb","posicao","pos",
               "frente_fundo","frente_fundo_sel","zona_fb","zona"]
    def _row_fb(r) -> str | None:
        for c in FB_COLS:
            if c in r and pd.notna(r[c]):
                v = str(r[c]).strip().upper()  # <<< correção: .upper() (sem .str)
                if v in ("FRENTE","F","FR","FRONTAL","ATAQUE"):
                    return "FRENTE"
                if v in ("FUNDO","B","U","BACK","TRAS","TRÁS","DEFESA"):
                    return "FUNDO"
        return None

    df0 = df.copy()
    df0["action_u"] = df0.get("action", "").astype(str).str.strip().str.upper()
    df0["who_u"]    = df0.get("who_scored", "").astype(str).str.strip().str.upper()
    df0["res_u"]    = df0.get("result", "").astype(str).str.strip().str.upper()
    if "player_number" in df0.columns:
        df0["player_number"] = pd.to_numeric(df0["player_number"], errors="coerce")

    # filtro por jogadoras (mantendo NaN)
    df_nos = df0.copy()
    if selected_players is not None and "player_number" in df_nos.columns:
        df_nos["player_number"] = df_nos["player_number"].astype("Int64")
        if len(selected_players) == 0:
            empty_dbg = pd.DataFrame(columns=["rally_no","player_number","action_u","res_u","who_u","used_x","used_y","origem","cor"])
            return ([], [], [], [], empty_dbg) if return_debug else ([], [], [], [])
        sel = pd.Series(selected_players, dtype="Int64")
        df_nos = df_nos[df_nos["player_number"].isin(sel) | df_nos["player_number"].isna()]

    # aceitamos estes nomes/códigos
    actions_ok = {
        "MEIO","M",
        "DIAGONAL","D",
        "LINHA","PARALELA","L",
        "LOB","LARGADA",
        "PIPE","PI",
        "SEGUNDA","SEG",
        "RECEPÇÃO","RECEPCAO","RE",
        "BLOQUEIO","B","BLOQ",
        "SAQUE","SA",
        "REDE"
    }

    succ_pts: list[dict] = []
    err_pts:  list[dict] = []
    adv_pts:  list[dict] = []
    adv_err_pts: list[dict] = []
    dbg_rows = []
    cluster_counters = {}

    group_bias = {
        "azul": (-0.8, -0.8),
        "vermelho": (0.8, -0.8),
        "laranja": (-0.8, 0.8),
        "laranja_escuro": (0.8, 0.8),
    }

    def _offset_for_index(idx: int, step_pct: float = 2.2) -> tuple[float, float]:
        if idx <= 0: return (0.0, 0.0)
        order = [
            (1,0), (-1,0), (0,1), (0,-1),
            (1,1), (-1,1), (1,-1), (-1,-1),
            (2,0), (-2,0), (0,2), (0,-2),
            (2,1), (2,-1), (-2,1), (-2,-1),
            (1,2), (-1,2), (1,-2), (-1,-2),
            (3,0), (-3,0), (0,3), (0,-3),
        ]
        base = order[(idx-1) % len(order)]
        mult = 1 + ((idx-1) // len(order))
        return (base[0]*step_pct*mult, base[1]*step_pct*mult)

    def _add_point(lst: list, x: float, y: float, color_tag: str, cluster_key: str, label: str | None, dbg_row: list):
        idx = cluster_counters.get(cluster_key, 0)
        dx, dy = _offset_for_index(idx)
        cluster_counters[cluster_key] = idx + 1
        gx, gy = group_bias.get(color_tag, (0.0, 0.0))
        xx = min(100.0, max(0.0, x + dx + gx))
        yy = min(100.0, max(0.0, y + dy + gy))
        lst.append({"x": xx, "y": yy, "label": label, "cluster": cluster_key})
        if return_debug:
            dbg_row = dbg_row.copy()
            dbg_row[5] = xx; dbg_row[6] = yy
            dbg_row[8] = color_tag
            dbg_rows.append(dbg_row)

    def _who_performed_is_nos(r) -> bool:
        """Deduza quem executou: NOS se (NOS,PONTO) ou (ADV,ERRO); senão ADV."""
        w = r.get("who_u","")
        res = r.get("res_u","")
        return (w == "NOS" and res == "PONTO") or (w == "ADV" and res == "ERRO")

    def _infer_point(r, color_tag: str, bucket: list, label: str | None):
        act = _norm_action(r.get("action_u",""))
        fb = _row_fb(r)

        # clique do usuário tem prioridade
        cx, cy = r.get("court_x"), r.get("court_y")
        if pd.notna(cx) and pd.notna(cy):
            x_use = float(cx)*100 if 0<=cx<=1 else float(cx)
            y_use = float(cy)*100 if 0<=cy<=1 else float(cy)
            _add_point(bucket, x_use, y_use, color_tag, f"{color_tag}:{act}", label,
                       [r.get("rally_no"), r.get("player_number"), act, r.get("res_u"), r.get("who_u"),
                        x_use, y_use, "clique", color_tag])
            return

        # metade para posicionar o Y: de quem EXECUTOU
        perf_is_nos = _who_performed_is_nos(r)
        eff_half = "our" if perf_is_nos else "opp"

        # recepção sempre na nossa metade
        if act == "RECEPÇÃO":
            eff_half = "our"

        # BLOQUEIO/REDE -> colado na rede + espalha no X
        if act in ("BLOQUEIO","REDE"):
            y0 = _y_net_touch(eff_half) if fb in (None, "FRENTE") else _y_for_half(eff_half, "FUNDO")
            idx = cluster_counters.get(f"{color_tag}:{act}", 0)
            x0 = 10.0 + (idx % 16) * (80.0/15.0)  # distribui ao longo da rede
        else:
            x0 = _x_for_action(act)
            y0 = _y_for_half(eff_half, fb)

        _add_point(bucket, x0, y0, color_tag, f"{color_tag}:{act}", label,
                   [r.get("rally_no"), r.get("player_number"), act, r.get("res_u"), r.get("who_u"),
                    x0, y0, "inferência", color_tag])

    # --------- listas ----------
    if include_success:
        srows = df_nos[(df_nos["who_u"] == "NOS") & (df_nos["res_u"] == "PONTO") & (df_nos["action_u"].isin(actions_ok))]
        for _, r in srows.iterrows():
            lbl = str(int(r["player_number"])) if pd.notna(r.get("player_number")) else None
            _infer_point(r, color_tag="azul", bucket=succ_pts, label=lbl)

    if include_errors:
        erows = df_nos[(df_nos["who_u"] == "ADV") & (df_nos["res_u"] == "ERRO") & (df_nos["action_u"].isin(actions_ok))]
        for _, r in erows.iterrows():
            lbl = str(int(r["player_number"])) if pd.notna(r.get("player_number")) else None
            _infer_point(r, color_tag="vermelho", bucket=err_pts, label=lbl)

    if include_adv_points:
        arows = df0[(df0["who_u"] == "ADV") & (df0["res_u"] == "PONTO") & (df0["action_u"].isin(actions_ok))]
        for _, r in arows.iterrows():
            _infer_point(r, color_tag="laranja", bucket=adv_pts, label=None)

    if include_adv_errors:
        aerr = df0[(df0["who_u"] == "NOS") & (df0["res_u"] == "ERRO") & (df0["action_u"].isin(actions_ok))]
        for _, r in aerr.iterrows():
            _infer_point(r, color_tag="laranja_escuro", bucket=adv_err_pts, label=None)

    if return_debug:
        dbg = pd.DataFrame(dbg_rows, columns=["rally_no","player_number","action_u","res_u","who_u","used_x","used_y","origem","cor"])
        return succ_pts, err_pts, adv_pts, adv_err_pts, dbg
    else:
        return succ_pts, err_pts, adv_pts, adv_err_pts

# =========================
# QUADRA HTML
# =========================
def render_court_html(pts_success, pts_errors, pts_adv=None, pts_adv_err=None, enable_click=False, key="set", show_numbers=False):
    """
    Desenha quadra com labels externos “ADV” (topo) e “NÓS” (baixo).
    """
    def _norm(points):
        out = []
        for it in points or []:
            if isinstance(it, dict):
                x = float(it.get("x", 0)); y = float(it.get("y", 0)); lab = it.get("label")
            elif isinstance(it, (list, tuple)) and len(it) >= 2:
                x = float(it[0]); y = float(it[1]); lab = None
            else:
                continue
            if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:
                x *= 100.0; y *= 100.0
            out.append((max(0.0, min(100.0, x)), max(0.0, min(100.0, y)), lab))
        return out

    S = _norm(pts_success)
    E = _norm(pts_errors)
    A = _norm(pts_adv or [])
    AE = _norm(pts_adv_err or [])
    container_id = f"uv-court-{key}"

    def _dot_html(x, y, bg, border, text=None):
        label_html = ""
        if show_numbers and text:
            label_html = (
                "<div style='position:absolute; inset:0; display:flex; align-items:center; justify-content:center; "
                "font-size:9px; color:#fff; font-weight:700;'>"
                f"{html.escape(str(text))}</div>"
            )
        return (
            f"<div style='left:{x}%; top:{y}%; width:12px; height:12px; position:absolute;"
            f"background:{bg}; border:1px solid {border}; border-radius:50%;"
            f"transform:translate(-50%,-50%); z-index:4;'>{label_html}</div>"
        )

    dots_html = []
    for x,y,lab in S:
        dots_html.append(_dot_html(x, y, "rgba(30,144,255,0.92)", "rgba(20,90,200,0.95)", lab))
    for x,y,lab in E:
        dots_html.append(_dot_html(x, y, "rgba(220,50,50,0.92)", "rgba(160,20,20,0.95)", lab))
    for x,y,lab in A:
        dots_html.append(_dot_html(x, y, "rgba(255,140,0,0.92)", "rgba(180,90,0,0.95)", lab or "ADV"))
    for x,y,lab in AE:
        dots_html.append(_dot_html(x, y, "rgba(210,100,0,0.92)", "rgba(150,70,0,0.95)", lab or "ADV"))

    click_js = ""
    if enable_click:
        click_js = f"""
        (function(){{
          const containerId = {json.dumps(container_id)};
          const root = document.getElementById(containerId);
          if (!root) return;
          root.addEventListener('click', function(e){{
            const rect = root.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            try {{
              const params = new URLSearchParams(window.parent.location.search || "");
              params.set('uv_click', x.toFixed(4) + ',' + y.toFixed(4));
              const newUrl = window.parent.location.pathname + '?' + params.toString() + window.parent.location.hash;
              window.parent.history.replaceState({{}}, '', newUrl);
              window.parent.location.reload();
            }} catch(err) {{
              const params = new URLSearchParams(window.location.search || "");
              params.set('uv_click', x.toFixed(4) + ',' + y.toFixed(4));
              const newUrl = window.location.pathname + '?' + params.toString() + window.location.hash;
              window.history.replaceState({{}}, '', newUrl);
              window.location.reload();
            }}
          }});
        }})();
        """

    html_block = f"""
    <div style="width:100%; text-align:center; font-weight:700; margin-bottom:6px;">ADV</div>
    <div id="{container_id}" style="background:#FFA94D; border:2px solid #333; position:relative; width:100%; height:380px; border-radius:6px;">
      <!-- REDE -->
      <div style="
           position:absolute; left:0; top:calc(50% - 8px); width:100%; height:16px;
           background:repeating-linear-gradient(90deg, rgba(255,255,255,0.95) 0 12px, rgba(0,0,0,0.12) 12px 14px);
           border-top:2px solid #111; border-bottom:2px solid #111; z-index:2; opacity:.95;"></div>
      <div style="position:absolute; left:0; top:50%; width:100%; height:2px; background:#111; z-index:3;"></div>
      <!-- Linhas de ataque (3m) -->
      <div style="position:absolute; left:0; top:33.333%; width:100%; height:1px; background:rgba(0,0,0,.30); z-index:1;"></div>
      <div style="position:absolute; left:0; top:66.666%; width:100%; height:1px; background:rgba(0,0,0,.30); z-index:1;"></div>

      {''.join(dots_html)}
    </div>
    <div style="width:100%; text-align:center; font-weight:700; margin-top:12px; margin-bottom:22px;">NÓS</div>
    <script>{click_js}</script>
    """
    components.html(html_block, height=468, scrolling=False)

# =========================
# Abertura de partida
# =========================
open_mid = last_open_match(frames)
if open_mid and st.session_state.match_id is None:
    st.session_state.match_id = int(open_mid)
    sets_m = frames["sets"]
    if not sets_m.empty and (sets_m["match_id"] == open_mid).any():
        st.session_state.set_number = int(sets_m[sets_m["match_id"] == open_mid]["set_number"].max())
    else:
        st.session_state.set_number = 1

home_name = away_name = date_str = ""
if st.session_state.match_id is not None:
    mt = frames["amistosos"]
    mrow = mt.loc[mt["match_id"] == st.session_state.match_id].iloc[0]
    home_name = team_name_by_id(frames, OUR_TEAM_ID)
    away_name = team_name_by_id(frames, mrow["away_team_id"])
    date_str = str(mrow["date"])

# topo
top1, top2, top3, top4, top5 = st.columns([2.5, 1, 1, 1, 1])
with top1:
    if home_name and away_name:
        st.markdown(f'<div class="badge"><b>{home_name}</b> x <b>{away_name}</b> — {date_str}</div>', unsafe_allow_html=True)
with top2:
    st.button("⚙️ Time", use_container_width=True, key="config_team_btn", on_click=lambda: st.session_state.__setitem__("show_config_team", True))
with top3:
    st.button("🆕 Jogo", use_container_width=True, key="new_game_btn", on_click=lambda: st.session_state.__setitem__("show_cadastro", True))
with top4:
    st.button("📘 Tutorial", use_container_width=True, key="tutorial_btn", on_click=lambda: st.session_state.__setitem__("show_tutorial", True))
with top5:
    hist_candidates = [
        "pages/02_historico.py",
        "pages/historico.py",
        "02_historico.py",
        "historico.py",
    ]
    found_hist = None
    for p in hist_candidates:
        if (BASE_DIR / p).exists():
            found_hist = p
            break
    def _go_hist(p=found_hist):
        try:
            st.switch_page(p)
        except Exception:
            st.warning("Não consegui abrir a página. Atualize seu Streamlit.")
    st.button("🗂️ Histórico", use_container_width=True, on_click=_go_hist)

# =========================
# Modais (Config/Tutorial)
# =========================
if st.session_state.get("show_config_team", False):
    st.markdown('<div class="sectionCard">', unsafe_allow_html=True)
    col_title, col_close = st.columns([4, 1])
    with col_title: st.subheader("⚙️ Nosso Time e Jogadoras")
    with col_close:
        st.button("❌ Fechar", key="close_config_top_btn", on_click=lambda: st.session_state.__setitem__("show_config_team", False))

    st.markdown("**Nome do Nosso Time**")
    current_team_name = team_name_by_id(frames, OUR_TEAM_ID)
    new_team_name = st.text_input("Nome do time:", value=current_team_name, key="team_name_input")
    def _save_team_name():
        if "equipes" in frames:
            equipes = frames["equipes"]; mask = equipes["team_id"] == OUR_TEAM_ID
            if mask.any(): equipes.loc[mask, "team_name"] = new_team_name
            else:
                new_team = pd.DataFrame({"team_id":[OUR_TEAM_ID], "team_name":[new_team_name]})
                equipes = pd.concat([equipes, new_team], ignore_index=True)
            frames["equipes"] = equipes; save_all(Path(st.session_state.db_path), frames)
            st.session_state.show_config_team = False
            dbg_print(f"Nome do time atualizado para '{new_team_name}'.")
    st.button("💾 Salvar Nome do Time", key="save_team_name_btn", on_click=_save_team_name)

    st.markdown("---"); st.subheader("👥 Jogadoras")
    jogadoras_df = frames.get("jogadoras", pd.DataFrame())
    our_players = jogadoras_df[jogadoras_df["team_id"] == OUR_TEAM_ID].copy()
    if not our_players.empty:
        st.markdown("**Cadastradas**")
        display_df = our_players[["player_number", "player_name", "position"]].copy()
        display_df.columns = ["Número", "Nome", "Posição"]; display_dataframe(display_df, height=140)
        st.markdown("**Excluir**")
        players_to_delete = our_players["player_number"].astype(str) + " - " + our_players["player_name"]
        player_to_delete = st.selectbox("Escolha:", players_to_delete.tolist(), key="delete_player_select")
        def _delete_player():
            if player_to_delete:
                player_num = int(player_to_delete.split(" - ")[0])
                jog_df = frames["jogadoras"]
                jog_df = jog_df[~((jog_df["team_id"] == OUR_TEAM_ID) & (jog_df["player_number"] == player_num))]
                frames["jogadoras"] = jog_df; save_all(Path(st.session_state.db_path), frames)
                dbg_print(f"Jogadora #{player_num} removida.")
        st.button("🗑️ Excluir", key="delete_player_btn", on_click=_delete_player)
    st.markdown("---"); st.subheader("➕ Adicionar")
    c1, c2, c3 = st.columns(3)
    with c1: new_number = st.number_input("Número:", min_value=1, max_value=99, key="new_player_number")
    with c2: new_name = st.text_input("Nome:", key="new_player_name")
    with c3: new_position = st.selectbox("Posição:", ["oposto","levantador","central","ponteiro","líbero"], key="new_player_position")
    def _add_player():
        if new_name.strip():
            new_player = pd.DataFrame({"team_id":[OUR_TEAM_ID],"player_number":[new_number],"player_name":[new_name],"position":[new_position]})
            if "jogadoras" in frames:
                jog_df = frames["jogadoras"]
                jog_df = jog_df[~((jog_df["team_id"] == OUR_TEAM_ID) & (jog_df["player_number"] == new_number))]
                jog_df = pd.concat([jog_df, new_player], ignore_index=True)
                frames["jogadoras"] = jog_df
            else:
                frames["jogadoras"] = new_player
            save_all(Path(st.session_state.db_path), frames)
            dbg_print(f"Jogadora adicionada: #{new_number} {new_name} ({new_position}).")
        else:
            st.warning("Digite um nome.")
    st.button("➕ Adicionar Jogadora", key="add_player_btn", on_click=_add_player)
    st.markdown('</div>', unsafe_allow_html=True)

if st.session_state.get("show_tutorial", False):
    try:
        html_path = BASE_DIR / "tutorial_scout.html"
        if html_path.exists():
            html_content = html_path.read_text(encoding="utf-8")
            components.html(
                f"""
                <div id='uv-modal' style='position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                 width: 90vw; height: 85vh; background-color: white; z-index: 1000;
                 border: 2px solid #ccc; border-radius: 10px; overflow: hidden;'>
                    <button id='uv-close'
                         style='position:absolute; top:10px; right:10px; z-index:1001; background:#ff4b4b; color:white;
                                border:none; border-radius:50%; width:30px; height:30px; cursor:pointer; font-weight:bold;'>X</button>
                    <iframe srcdoc='{html.escape(html_content)}'
                             style='width:100%; height:100%; border:none; margin-top:40px;'></iframe>
                </div>
                <script>
                  (function(){{
                    const btn = document.getElementById('uv-close');
                    btn.addEventListener('click', function(){{
                      try {{
                        const url = new URL(window.parent.location.href);
                        url.searchParams.set('uv_tutorial_close','1');
                        window.parent.history.replaceState({{}}, '', url);
                        document.getElementById('uv-modal').style.display='none';
                      }} catch(e) {{}}
                    }});
                  }})();
                </script>
                """,
                height=900, scrolling=True
            )
            params = dict(st.query_params)
            if params.get("uv_tutorial_close") == "1":
                st.session_state.show_tutorial = False
                newp = {k: v for k, v in dict(st.query_params).items() if k != "uv_tutorial_close"}
                st.query_params.from_dict(newp)
        else:
            st.error("Arquivo de tutorial não encontrado.")
    except Exception as e:
        st.error(f"Não consegui abrir o tutorial: {e}")
    st.button("❌ Fechar Tutorial", key="close_tutorial_btn", on_click=lambda: st.session_state.__setitem__("show_tutorial", False))

# =========================
# Cadastro rápido / NOVO JOGO
# =========================
def _get_or_create_team_id_by_name(frames: dict, name: str) -> int:
    name_norm = str(name).strip()
    if not name_norm:
        return 2
    eq = frames.get("equipes", pd.DataFrame())
    if not eq.empty:
        hit = eq[eq["team_name"].astype(str).str.strip().str.lower() == name_norm.lower()]
        if not hit.empty:
            return int(hit.iloc[0]["team_id"])
        next_id = int(pd.to_numeric(eq["team_id"], errors="coerce").max() or 1) + 1
        if next_id == OUR_TEAM_ID: next_id += 1
        eq = pd.concat([eq, pd.DataFrame([{"team_id": next_id, "team_name": name_norm}])], ignore_index=True)
    else:
        next_id = 2 if OUR_TEAM_ID == 1 else 1
        eq = pd.DataFrame([{"team_id": next_id, "team_name": name_norm}])
    frames["equipes"] = eq
    return int(next_id)

def _create_new_match(opp_name: str, dt: date):
    frames_local = st.session_state.frames
    mt = frames_local.get("amistosos", pd.DataFrame())
    if mt.empty:
        mt = pd.DataFrame(columns=["match_id","away_team_id","date","home_sets","away_sets"])
        next_mid = 1
    else:
        next_mid = int(pd.to_numeric(mt["match_id"], errors="coerce").max() or 0) + 1
    away_id = _get_or_create_team_id_by_name(frames_local, opp_name or "Adversário")
    new_row = {"match_id": next_mid, "away_team_id": away_id, "date": str(dt), "home_sets": 0, "away_sets": 0}
    mt = pd.concat([mt, pd.DataFrame([new_row])], ignore_index=True)
    frames_local["amistosos"] = mt
    add_set(frames_local, match_id=next_mid, set_number=1)
    save_all(Path(st.session_state.db_path), frames_local)
    st.session_state.frames = frames_local
    st.session_state.match_id = next_mid
    st.session_state.set_number = 1
    st.session_state.show_cadastro = False
    st.success(f"Novo jogo criado: {team_name_by_id(frames_local, OUR_TEAM_ID)} x {opp_name or team_name_by_id(frames_local, away_id)}")
    dbg_print(f"Novo jogo criado (match_id={next_mid}) contra '{opp_name}' na data {dt}.")
if (st.session_state.match_id is None or st.session_state.show_cadastro) and not st.session_state.show_config_team:
    with st.container():
        st.markdown('<div class="sectionCard">', unsafe_allow_html=True)
        st.subheader("🆕 Novo Jogo")

        cgj1, cgj2, cgj3 = st.columns([2, 1, 1])
        with cgj1:
            opp_name = st.text_input("Adversário:", key="new_game_opponent", value="")
        with cgj2:
            game_date = st.date_input("Data:", value=date.today(), key="new_game_date")
        with cgj3:
            st.markdown('<div class="btn-xxs" style="margin-top:20px;">', unsafe_allow_html=True)
            st.button("Criar Jogo", key="create_game_btn",
                      on_click=lambda: _create_new_match(st.session_state.get("new_game_opponent","").strip(), st.session_state.get("new_game_date", date.today())))
            st.markdown('</div>', unsafe_allow_html=True)

        st.markdown("---")
        st.subheader("🎯 Registrar Rally (Pré-jogo)")

        def on_submit_text_pre():
            raw = st.session_state.get("line_input_text", "").strip()
            if not raw: return
            quick_register_line(raw)
            st.session_state["line_input_text"] = ""
            st.session_state["q_side"] = "Nós"; st.session_state["q_result"] = "Acerto"; st.session_state["q_action"] = "d"; st.session_state["q_position"] = "Frente"

        _ = st.text_input("Digite código:", key="line_input_text", placeholder="Ex: 1 9 d",
                          label_visibility="collapsed", on_change=on_submit_text_pre)

        def _cb_register_pre():
            register_current(); st.session_state["line_input_text"] = ""

        c_reg_pre, c_undo_pre = st.columns([1, 1])
        with c_reg_pre:
            st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
            st.button("➕ Registrar", use_container_width=True, key="register_btn_pre", on_click=_cb_register_pre)
            st.markdown('</div>', unsafe_allow_html=True)
        with c_undo_pre:
            st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
            st.button("↩️ Desfazer Rally", use_container_width=True, key="undo_btn_pre", on_click=undo_last_rally_current_set)
            st.markdown('</div>', unsafe_allow_html=True)

        st.markdown('</div>', unsafe_allow_html=True)
    st.stop()

# =========================
# Barra do sistema
# =========================
with st.container():
    st.markdown('<div class="sectionCard">', unsafe_allow_html=True)

    bar1, bar3, bar4, bar5 = st.columns([1.4, 3.2, 1.2, 1.4])
    with bar1:
        st.session_state.auto_close = st.toggle("Auto 25/15+2", value=st.session_state.auto_close, key="auto_close_toggle")
        st.session_state.game_mode = st.toggle("🎮 Modo Jogo", value=st.session_state.game_mode, key="game_mode_toggle")
    with bar3:
        sets_match_all = frames["sets"].loc[frames["sets"]["match_id"] == st.session_state.match_id].sort_values("set_number")
        sel_vals = sets_match_all["set_number"].tolist() if not sets_match_all.empty else [1]
        c31, c32, c33 = st.columns([1, 1, 1])
        with c31:
            set_to_reopen = st.selectbox("Set:", sel_vals, label_visibility="collapsed", key="set_select")
        def _close_set():
            frames_local = st.session_state.frames
            df_cur = current_set_df(frames_local, st.session_state.match_id, int(set_to_reopen))
            if df_cur.empty: st.warning("Sem rallies neste set.")
            else:
                hp, ap = set_score_from_df(df_cur)
                if hp == ap: st.warning("Empate — defina o set antes.")
                else:
                    _apply_set_winner_and_proceed(hp, ap)
                    st.session_state.data_rev += 1
        with c32:
            st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
            st.button("🔓 Reabrir Set", use_container_width=True, key="reopen_btn",
                      on_click=lambda: dict() if 'reopen_set' in globals() and callable(globals()['reopen_set']) and globals()['reopen_set'](st.session_state.match_id, int(set_to_reopen)) else None)
            st.markdown('</div>', unsafe_allow_html=True)
        with c33:
            st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
            st.button("✅ Fechar Set", use_container_width=True, key="close_set_btn", on_click=_close_set)
            st.markdown('</div>', unsafe_allow_html=True)
    with bar4:
        def _remove_empty_set():
            frames_local = st.session_state.frames
            stf = frames_local["sets"]; rl = frames_local["rallies"]; mid = st.session_state.match_id
            sets_m = stf[stf["match_id"]==mid]
            if sets_m.empty: st.warning("Sem sets cadastrados.")
            else:
                max_set = int(sets_m["set_number"].max())
                sub = rl[(rl["match_id"]==mid) & (rl["set_number"]==max_set)]
                if not sub.empty: st.warning(f"O Set {max_set} tem rallies e não será removido.")
                else:
                    stf = stf[~((stf["match_id"]==mid) & (stf["set_number"]==max_set))]
                    frames_local["sets"] = stf; save_all(Path(st.session_state.db_path), frames_local); st.success(f"Set {max_set} removido.")
                    st.session_state.frames = frames_local
                    st.session_state.data_rev += 1
        st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
        st.button("🗑️ Remover Set Vazio", use_container_width=True, key="remove_empty_set_btn", on_click=_remove_empty_set)
        st.markdown('</div>', unsafe_allow_html=True)
    with bar5:
        st.session_state.graph_filter = st.radio("Filtro Gráficos:", options=["Nós","Adversário","Ambos"],
            horizontal=True, index=["Nós","Adversário","Ambos"].index(st.session_state.graph_filter), key="graph_filter_radio")
    st.markdown('</div>', unsafe_allow_html=True)

# =========================
# PLACAR
# =========================
with st.container():
    st.markdown('<div class="sectionCard">', unsafe_allow_html=True)

    frames = st.session_state.frames

    df_set = current_set_df(frames, st.session_state.match_id, st.session_state.set_number)
    home_pts, away_pts = set_score_from_df(df_set)
    stf = frames["sets"]; sm = stf[stf["match_id"] == st.session_state.match_id]
    home_sets_w = int((sm["winner_team_id"] == 1).sum()); away_sets_w = int((sm["winner_team_id"] == 2).sum())

    pc1, pc2, pc3, pc4 = st.columns([1.1, .8, 1.1, 2.2])
    with pc1:
        st.markdown(f"<div class='score-box'><div class='score-team'>{home_name}</div><div class='score-points'>{home_pts}</div></div>", unsafe_allow_html=True)
    with pc2:
        st.markdown("<div class='score-box'><div class='score-x'>×</div></div>", unsafe_allow_html=True)
    with pc3:
        st.markdown(f"<div class='score-box'><div class='score-team'>{away_name}</div><div class='score-points'>{away_pts}</div></div>", unsafe_allow_html=True)
    with pc4:
        st.markdown(f"<div class='set-summary'>Sets: <b>{home_sets_w}</b> × <b>{away_sets_w}</b> &nbsp;|&nbsp; Set atual: <b>{st.session_state.set_number}</b></div>", unsafe_allow_html=True)

    st.markdown('</div>', unsafe_allow_html=True)

# =========================
# MODO JOGO
# =========================
if st.session_state.game_mode:
    with st.container():
        st.markdown('<div class="sectionCard game-mode-container">', unsafe_allow_html=True)
        st.subheader("🎮 Modo Jogo")

        st.caption("Jogadoras (toque rápido define lado = Nós):")
        label_mode_col, _ = st.columns([1.0, 3.0])
        with label_mode_col:
            st.session_state.player_label_mode = st.radio(
                "Mostrar botões por:", options=["Número","Nome"], horizontal=True,
                index=["Número","Nome"].index(st.session_state.player_label_mode),
                key="player_label_mode_gm"
            )
        nums = resolve_our_roster_numbers(st.session_state.frames)
        name_map = {r["number"]: r["name"] for r in roster_for_ui(st.session_state.frames)}

        if nums:
            num_cols = 12 if st.session_state.player_label_mode == "Número" else 4
            jcols = st.columns(num_cols)
            for i, n in enumerate(nums):
                label_txt = str(n) if st.session_state.player_label_mode == "Número" else (name_map.get(n) or str(n))
                with jcols[i % num_cols]:
                    st.button(
                        f"{label_txt}",
                        key=f"gm_pill_{n}",
                        on_click=lambda n=n: (st.session_state.__setitem__("last_selected_player", n),
                                              st.session_state.__setitem__("q_side", "Nós")),
                        use_container_width=True
                    )
            with jcols[(len(nums)) % num_cols]:
                st.button("ADV", key="gm_adv_btn",
                          on_click=lambda: st.session_state.__setitem__("q_side", "Adv"),
                          use_container_width=True)
        else:
            st.caption("Sem jogadoras")

        st.caption("Resultado / Posição:")
        rc1, rc2 = st.columns([1.2, 1.0])
        with rc1:
            st.session_state.q_result = st.radio("Resultado", options=["Acerto","Erro"], horizontal=True, index=0,
                                                 key="gm_q_result", label_visibility="collapsed")
        with rc2:
            st.session_state.q_position = st.radio("Posição", options=["Frente","Fundo"], horizontal=True,
                                                   index=["Frente","Fundo"].index(st.session_state.q_position),
                                                   key="gm_q_position", label_visibility="collapsed")

        st.caption("Atalhos de Ação:")
        acols = st.columns(12)
        for i, code in enumerate(["d","l","m","lob","seg","pi","re","b","sa","rede"]):
            with acols[i % len(acols)]:
                label = ACT_MAP.get(code, code)[:3]
                st.button(label, key=f"gm_quick_{code}",
                          on_click=lambda code=code: register_current(action=code), use_container_width=True)

        st.button("↩️ Desfazer Rally", use_container_width=True, key="gm_undo_btn", on_click=undo_last_rally_current_set)

        st.markdown("---")
        st.markdown("**🗺️ Mapa de Calor (clique para marcar o local do ataque)**")

        st.session_state.show_heat_numbers = st.checkbox(
            "Mostrar número/ADV nas bolinhas (nossos + adversário)",
            value=st.session_state.show_heat_numbers, key="gm_show_numbers_chk"
        )

        df_hm = current_set_df(st.session_state.frames, st.session_state.match_id, st.session_state.set_number)
        pts_succ, pts_errs, pts_adv, pts_adv_err, dbg_gm = build_heat_points(
            df_hm,
            selected_players=None,
            include_success=True,
            include_errors=True,
            include_adv_points=True,
            include_adv_errors=True,
            return_debug=True
        )

        dbg_print(f"[Modo Jogo] Heatmap: succ={len(pts_succ)} err={len(pts_errs)} adv={len(pts_adv)} advErr={len(pts_adv_err)} (set={st.session_state.set_number})")

        render_court_html(pts_succ, pts_errs, pts_adv, pts_adv_err, enable_click=True, key="gm", show_numbers=st.session_state.show_heat_numbers)

        with st.expander("🔎 Debug Heatmap (Modo Jogo)"):
            st.write(f"Acertos (azul): **{len(pts_succ)}**  |  Erros (vermelho): **{len(pts_errs)}**  |  ADV (laranja): **{len(pts_adv)}**  |  ADV erros: **{len(pts_adv_err)}**")
            if not dbg_gm.empty:
                view = dbg_gm[["rally_no","player_number","action_u","res_u","who_u","used_x","used_y","origem","cor"]].tail(20)
                display_dataframe(view, height=180, use_container_width=True)
            else:
                st.write("_Sem registros elegíveis._")

        lc = st.session_state.get("last_court_click")
        if lc:
            st.caption(f"🧪 Último clique capturado: x={lc['x']:.2f}  y={lc['y']:.2f}  (será anexado ao próximo registro)")
        else:
            st.caption("🧪 Nenhum clique pendente. Clique na quadra para capturar x/y.")

        st.markdown('</div>', unsafe_allow_html=True)

    st.stop()

# =========================
# Painel principal
# =========================
with st.container():
    st.markdown('<div class="sectionCard">', unsafe_allow_html=True)

    frames = st.session_state.frames
    df_set = current_set_df(frames, st.session_state.match_id, st.session_state.set_number)

    left, right = st.columns([1.25, 1.0])

    # -------- ESQUERDA --------
    with left:
        st.markdown("**🎯 Registrar Rally**")

        def on_submit_text_main():
            raw = st.session_state.get("line_input_text", "").strip()
            if not raw: return
            quick_register_line(raw)
            st.session_state["line_input_text"] = ""
            st.session_state["q_side"] = "Nós"; st.session_state["q_result"] = "Acerto"; st.session_state["q_action"] = "d"; st.session_state["q_position"] = "Frente"

        st.text_input("Digite código:", key="line_input_text",
                      placeholder="Ex: 1 9 d", label_visibility="collapsed", on_change=on_submit_text_main)

        def _cb_register_main():
            register_current(); st.session_state["line_input_text"] = ""

        c_reg, c_undo = st.columns([1, 1])
        with c_reg:
            st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
            st.button("➕ Registrar", use_container_width=True, key="register_btn_main", on_click=_cb_register_main)
            st.markdown('</div>', unsafe_allow_html=True)
        with c_undo:
            st.markdown('<div class="btn-xxs">', unsafe_allow_html=True)
            st.button("↩️ Desfazer Rally", use_container_width=True, key="undo_btn_main", on_click=undo_last_rally_current_set)
            st.markdown('</div>', unsafe_allow_html=True)

        # Jogadoras (Número/Nome)
        st.caption("Jogadoras (selecione):")
        label_mode_col, _ = st.columns([1.0, 3.0])
        with label_mode_col:
            st.session_state.player_label_mode = st.radio(
                "Mostrar botões por:", options=["Número","Nome"], horizontal=True,
                index=["Número","Nome"].index(st.session_state.player_label_mode),
                key="player_label_mode_main"
            )

        nums = resolve_our_roster_numbers(frames)
        name_map = {r["number"]: r["name"] for r in roster_for_ui(frames)}

        if nums:
            num_cols = 12 if st.session_state.player_label_mode == "Número" else 4
            jcols = st.columns(num_cols)
            for i, n in enumerate(nums):
                label_txt = str(n) if st.session_state.player_label_mode == "Número" else (name_map.get(n) or str(n))
                with jcols[i % num_cols]:
                    st.button(
                        f"{label_txt}",
                        key=f"pill_main_{n}",
                        on_click=lambda n=n: (st.session_state.__setitem__("last_selected_player", n),
                                              st.session_state.__setitem__("q_side", "Nós")),
                        use_container_width=True
                    )
            with jcols[(len(nums)) % num_cols]:
                st.button("ADV", key="pill_main_adv",
                          on_click=lambda: st.session_state.__setitem__("q_side", "Adv"),
                          use_container_width=True)
            sel = st.session_state.get("last_selected_player")
            if sel is

-------------------------------


frente e fundo, mas diagonal e paralela nao, corrija e me envie o trecho ou funcao completa corrigida"
me envie novamente o codigo completo sem retirar ou errar em nada e em 3 partes

botao largada, segunda, pipe e recepcao nao estao registrando bolinhas (recepcao registra apenas vermelhas)
e essas e nenhum outro registro de bolinhas está respeitando o botao frente e fundo.. todas estao sendo colocadas após a linha dos 3 metros que citei (como fundo). se selecionado "frente" elas devem ser marcadas próxima a rede (nao tanto quando bloqueio), mas antes das linha branca dos 3 metros. corrija apenas isso e me envie o codigo dessa uncao final e completo

e o botao de atalho de acao de rede precisa ser adicionado e registrar sempre uma bolinha vermelha bem colado a rede, pode ser nela inteira, nao so no meio ou nos cantos, igual ao bloqueio. se a insercao desse botao for em outra funcao ou css me envie apenas o codigo dele e mais ou menos a linha a ser inserido


******************************
me envie o codigo final em 3 partes novamente, vou te enviando as partes finalizadas e se tiver erro no meio do envio vc me envia as partes faltantes apenas

as bolinhas de meio estao respeitando o frente e fundo, mas diagonal e paralela nao, corrija e me envie o trecho ou funcao completa corrigida
os botoes, pipe, segunda e saque precisam ir para o meio da quadra (respeintando as regras de  frente e fundo e pontuacao e erro e se for ponto nosso, bolinha para a quadra adv e se for erro nosso para a nossa quadra adv. inverso para o adv
o botao bloqueio registra bolinhas beem coladas na rede (pode ser em toda extensao dela) se for na frente, e fundo se for selecionado fundo




******************************

ULTIMOS AJUSTES

seguem ajustes finais
:

e por ultimo e talvez mais dificil: inserir  ao lado de Resultado: Acerto Erro use a mesma estrutura para inserir "Posição" Frente, Fundo (se vc conseguir pode usar essa informação para a posicao das bolinhas na quadra. Se for frente é mais a frente próximo a rede, se for fundo é mais perto da linha de fundo da quadra.. acha que consegue?


o título "Nós" abaixo da quadra cortou um pouco (AGORA NEM APARECE MAIS), dê mais espaço antes do texto "Acertos (azul): 0 | Erros (vermelho): 7 | ADV pontos (laranja): 1 | ADV erros (laranja escuro): 4" etc


No modo jogo sumiram algumas bolinhas da quadra, especialmente as do adv. Deve ser o mesmo comportamento, apenas com a quadra mais próxima da marcação de pontos. No modo jogo vc pode sumir com o botao registrar.

o botao mei precisa ser aumentada a largura um pouco

de resto nao erre ou retire nada, graficos, tabelas, nada, está perfeito!!!

******************************
achei o desfazer rally um pouco lento, verifique e tente melhorar

Ao Mostrar botões por nome, deixe os botoes com o tamanho dos nomes (atualmente altuns estao com o nome cortando)

PEDI PARA VC ALTERAR E NAO CORRIGIU (PRESTE ATENCAO E FAÇA!) pode aumentar um pouco mais os textos dessa parte:
Univolei
16
×
tes
8
Sets: 1 × 0  |  Set atual: 2
o mostrar numero das jogadoras nas bolinhas ficou muito bom, implemente o nome "adv" tb nas bolinhas de acertos e erros das adv
verifique se esse botao limpar ultimo clique é necessário, nem sei para que ele serve e parece que está sem funcao, sem fazer nada


PEDI PARA VC ALTERAR E NAO CORRIGIU  vou te enviar meu css completo atual para correção, me envie ele completo com esses ajustes. Obs: o botao histórico está diferente dos demais (parece que falta o quadro em volta, ajuste isso
e Univolei x tes — 2025-08-26 e Jogo: Univolei x tes — 2025-08-26 aparecem duas vezes parece, deixe apenas a primeira que tem o quadro destacando 

coloque o Mapa de Calor (Quadra) antes das tabelas de kpis

remova a coluna action da tabela Ataques ponto por tipo (nossos)



******************************



uhuuu!!! primeiras bolinhas marcadas na quadra!! parece que saímos do lugar e evoluiímos um pouco!!
mantenha assim os debugs e verifique os ajustes que ainda preciso
1. na quadra, insira do lado de fora do desenho uma descrição "Nós" e outra "Adv".
Os registros de ponto nosso, vc deve marcar na quadra adv (todos em azul)
os registros de erros nosso (paralela e diagonal) vc marca na quadra adv, os de recepção na nossa quadra (todos em vermelho)
os pontos que está marcando na quadra, estão se sobrescrevendo sempre na mesma posição e isso não pode acontecer. Se houverem mais de um acerto na diagonal, devem ser criados 2 pontos em azul, e assim sucessivamente. Cuidado em relação ao tamanho e espaço (pode ir aumentando a quadra se necessário), pois podem haver 25 pontos no mesmo lugar, e ficariam 25 pontos na paralela, por exemplo, ok? sempre um do lado do outro próximos em cada registro de pontuação (meio, paralela e diagonal)
Os pontos de acerto da adv podem continuar em laranja, mas tbcom vários pontos na quadra, sempre um do lado do outro . Os pontos de erros dela, podem ser um laranja mais escuro
Junto aos filtros de acerto, erro e adv (laranja) coloque um a mais, que irá ativar a numeração de cada nossa jogadora (veja uma forma de fazer isso se uma cor para cada atleta ou o numero dela do lado ou até dentro da bolinha marcada. Para isso rveja o tamanho da quadra e pode ser bem pequena a numeração, mas que dê leitura.
veja o debug em tela, pode te ajudar nas posições das bolinhas
🔎 Debug Heatmap (Set atual)

Acertos (azul): 0 | Erros (vermelho): 3 | ADV (laranja): 3

rally_no	player_number	action_u	res_u	who_u	used_x	used_y	origem	cor
7	2.0	LINHA	ERRO	ADV	82.0	72.0	inferência	vermelho
8	2.0	DIAGONAL	ERRO	ADV	28.0	72.0	inferência	vermelho
9	5.0	MEIO	ERRO	ADV	50.0	62.0	inferência	vermelho
1	NaN	LINHA	PONTO	ADV	82.0	72.0	inferência	laranja
4	NaN	LINHA	PONTO	ADV	82.0	72.0	inferência	laranja
5	NaN	DIAGONAL	PONTO	ADV	28.0	72.0	inferência	laranja


Faça o envio do código completo e corrigido (sem erros e sem retirar nada) em partes ou até divida em 3 arquivos ou em uma estrutura simples e melhor, pois meu código está aumentando e toda vez que peço correção está falhando o envio completo.
Tome muito cuidado para não errar e mantenha o histórico do que já estamos evoluindo ou já erramos, para não falharmos novamente



******************************

Como desenvolvedor pyton experiente corrija meu código index e o css, nao retire ou erre em nada e me envie as correções abaixo com o código 100%  final e completo, sem cortes 
1. Aba lateral iniciar recolhida
2. As tabelas de kpi estão com layout ruim para leitura, com fundo ou fonte branca. Faça com que fique mais visual e bom para análise
3. Faça uma quadra de volei como de mapa de calor de erros e acertos de nossas jogadoras com a posição da quadra que mais atacaram e erraram. Posso ter a opção de filtro por jogador (ex: so quero ver acertos ou erros da jogadora 9 apenas, ou quero ver da 9 e 11 juntas)
4. Faça um "modo jogo", que so vai ter a marcação de pontos com a numeração de jogadores, escolha de equipe, acerto e erros, os atalhos e o mapa.de calor que vc irá montar. Se eu sair do modo jogo volta a mostrar todo o layout. Esse talvez substitua o gráfico de tendência de equipe, mas me confirme se eles são semelhantes e podem ser unidos desta forma que indiquei.
4. Os atalhos de equipe (nos e adv) pode ser transformado em um botão a mais no final da lista de numeração de jogadoras. Ele seria um botão "adv" e desta forma nao precisaria desta seção de equipe+nos e adv.
corrija isso e apenas isso e me envie o codigo final sem erros e completo


Corrigir layout para celular, otimizando ao maximo a marcação dos pontos ( a parte de numeração da equipe ate os atalhos precisa caber em uma tela unica de celular). Parece que o css que vc indicou para celular nao esta sendo reconhecido, crie um debug no código talvez pra indicar que foi lido e eu te confirme. A versão pra PC no celular ate agora ficou melhor qhe a versão celular. Preciso corrigir isso de forma definitiva 






******************************


alem das correcoes que vou enviar, emcima dos botoes da numeracao das jogadoras, adicione uma opcao que eu poderei selecionar o label dos botoes, ou com a numeracao como esta, ou com o nome delas que tb tem na base de dados. mesmo se eu clicar e deixar o nome nos botoes, o registro de ponto será pela numeracao, ok? o nome é apenas visual nos botoes em caso de eu preferir assim

******************





1. procurar melhores ias do próprio chatgpt para codificação

2. procurar scouts já realizados e prontos para indicação de boas praticas e apoio do que já existe prnto
*********************************************************************
Com os dados registrados dos sets, já crie uma segunda pagina com um dash dos principais infirmacoes destas que vou lhe enviar, ok? pode ser 70% disso, dos mais importantes


Ataque
Eficiência de ataque (EFF) = (Pontos de ataque − Erros de ataque − Bloqueios sofridos) / Tentativas de ataque
%Ponto de ataque = Pontos de ataque / Tentativas de ataque
Distribuição do levantador = tentativas por posição / tentativas totais

Recepção
%Recepção perfeita = Recepções perfeitas / Total de recepções

Saque
Ace% = Aces / Saques
Erro% = Erros de saque / Saques
Pressão de saque = Aces + recepções ruins (C) forçadas / Saques

Bloqueio/Defesa
Bloqueios ponto/set
Toques de bloqueio que geram transição% = Rallies com toque de bloco → ataque nosso / toques de bloco
Defesas efetivas% = Defesas que permitem contra-ataque / Defesas

Erro
Erros não forçados por set
Taxa de erro por rotação = Erros cometidos quando na rotação r / rallies na rotação r
Contexto
Eficiência por rotação = (Pontos − Erros) / Rallies na rotação
Clutch: saldo de pontos em faixas [20–25] ou diferença ≤2 pts

6. Alertas inteligentes (em tempo real)
Regra: Erro de saque ≥ X% em janela de 10 saques → alerta “mudar alvo/risco”.
Regra: Side-out% por rotação < meta (ex.: 60%) em janela de 8 rallies → sugerir substituição/variação.
Regra: Levantador com distribuição >50% em um atacante → sugerir diversificar.
Regra: Recepção C > Y% em um recebedor → “proteger com dupla recepção”.

7. Metas/benchmarks (referências práticas)
Side-out%: 60–70% bom; >70% excelente (contexto adulto).
Ace%: 5–10% bom; Erro de saque: 10–15% aceitável dependendo da estratégia.
Recepção perfeita%: 30–45% bom.
EFF ataque: >0,25 ponta/oposto; meios podem passar disso.
Dashboard com 5 visuais principais: Momentum, Pareto de erros, Side-out por rotação, Mapa de recepção, Distribuição do levantador.
************************************************************************


3. KPIs essenciais (com fórmulas)
Use por time, set, rotação e jogador.

Ataque
Eficiência de ataque (EFF) = (Pontos de ataque − Erros de ataque − Bloqueios sofridos) / Tentativas de ataque
%Ponto de ataque = Pontos de ataque / Tentativas de ataque
Distribuição do levantador = tentativas por posição / tentativas totais

Recepção
%Recepção perfeita = Recepções perfeitas / Total de recepções

Saque
Ace% = Aces / Saques
Erro% = Erros de saque / Saques
Pressão de saque = Aces + recepções ruins (C) forçadas / Saques

Bloqueio/Defesa
Bloqueios ponto/set
Toques de bloqueio que geram transição% = Rallies com toque de bloco → ataque nosso / toques de bloco
Defesas efetivas% = Defesas que permitem contra-ataque / Defesas

Erro
Erros não forçados por set
Taxa de erro por rotação = Erros cometidos quando na rotação r / rallies na rotação r
Contexto
Eficiência por rotação = (Pontos − Erros) / Rallies na rotação
Clutch: saldo de pontos em faixas [20–25] ou diferença ≤2 pts

6. Alertas inteligentes (em tempo real)
Regra: Erro de saque ≥ X% em janela de 10 saques → alerta “mudar alvo/risco”.
Regra: Side-out% por rotação < meta (ex.: 60%) em janela de 8 rallies → sugerir substituição/variação.
Regra: Levantador com distribuição >50% em um atacante → sugerir diversificar.
Regra: Recepção C > Y% em um recebedor → “proteger com dupla recepção”.

7. Metas/benchmarks (referências práticas)
Side-out%: 60–70% bom; >70% excelente (contexto adulto).
Ace%: 5–10% bom; Erro de saque: 10–15% aceitável dependendo da estratégia.
Recepção perfeita%: 30–45% bom.
EFF ataque: >0,25 ponta/oposto; meios podem passar disso.
Dashboard com 5 visuais principais: Momentum, Pareto de erros, Side-out por rotação, Mapa de recepção, Distribuição do levantador.


Índice de recepção (0–3) = (Σ notas) / Total
Side-out% = Pontos ganhos quando recebemos o saque / Rallies em que recebemos

4. Visuais e gráficos (prontos para implementar)
Tempo real (match dashboard)
Score & Momentum: linha cumulativa do saldo de pontos (nós − eles) por rally; marcações de tempos/pedidos.
Controle estatístico de erro (p-chart) por janela móvel (ex.: últimos 10 rallies) com limites (média ± 2σ) → alerta de “deriva de erro”.
Side-out vs Break-point por rotação (grid 1–6), com barras lado a lado.
Mapa de calor de recepção (6 zonas) com intensidade de qualidade (0–3).
Sankey do rally: recepção→levantamento→zona de ataque→resultado (ótimo para leitura do fluxo).
Radar por jogador: EFF ataque, Ace%, Erro%, Recepção perfeita%, Participação em transição.
Matriz de distribuição do levantador (linhas = rotação, colunas = atacante) com % de bolas.
Shot chart de ataque: origem (zona 4/3/2/pipe/6) → destino (1–6 adversário) e resultado (ponto/defendido/bloqueado).
Gantt de rotações: períodos em que cada rotação ficou em quadra e saldo por rotação.
Pareto de erros (por tipo: saque, ataque, recepção, técnica).
Pós-jogo / evolução
Trend semanal/mensal de EFF, Side-out%, Ace% e Erro% com média móvel.
Boxplots por jogador (variação set a set de EFF, recepção, etc.).
Comparativo por adversário (histórico vs oponentes).
Mapa de calor de “alvos de saque” (quem recebeu e com que qualidade).
Clutch chart: eficiência em pontos 20–25 e tie-break.

5. Tabelas/relatórios úteis
Tabela de rotação (por set):
Rotação | Rallies | Side-out% | Break-point% | EFF | Erros | Aces | Bloqueios ponto | Saldo

Tabela por jogador:
Jogador | Ataques (P/B/ER/DEF) | EFF | Saques (ACE/ER) | Recepção (A/B/C) | Bloqueios ponto | Defesa efetiva% | PPS (pontos por set)

Tabela de distribuição do levantador:
Rotação | Oposto% | Ponta1% | Ponta2% | Meio1% | Meio2% | Pipe% | Altura média (se tiver)

Tabela de alvos de saque:
Recebedor | Saques recebidos | A/B/C | %Perfeita | Side-out% após recepção

